module Database (..) where


type alias Function =
    { name : String
    , signature : String
    , documentation : String
    , declaration : String
    }


functions : List Function
functions =
    [ { name = "identity", signature = "a -> a", documentation = "identity(x) == x", declaration = "template <typename T>\nT identity(const T& x)" }
    , { name = "is_equal", signature = "a, a -> bool", documentation = "x == y", declaration = "template <typename T>\nbool is_equal(const T& x, const T& y)" }
    , { name = "always", signature = "a, b -> a", documentation = "always(x, y) == x", declaration = "template <typename Y, typename X>\nstd::function<X(const Y&)> always(const X& x)" }
    , { name = "is_equal_by_and_by", signature = "(a -> b), (c -> b) -> a, c -> bool", documentation = "f(x) == g(y)", declaration = "template <typename F, typename G,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GOut = typename utils::function_traits<G>::result_type>\nstd::function<bool(const FIn& x, const GIn& y)>\n        is_equal_by_and_by(F f, G g)" }
    , { name = "is_equal_by", signature = "(a -> b) -> a -> bool", documentation = "f(x) == f(y)", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<bool(const FIn& x, const FIn& y)>\n        is_equal_by(F f)" }
    , { name = "is_equal_by", signature = "(b -> a), a -> (b -> bool)", documentation = "f(y) == x", declaration = "template <typename F, typename X,\n    typename Y = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<bool(const Y&)> is_equal_by_to(F f, const X& x)" }
    , { name = "is_equal_to", signature = "a -> a -> bool", documentation = "x == y\ncurried version of is_equal", declaration = "template <typename X>\nstd::function<bool(const X&)> is_equal_to(const X& x)" }
    , { name = "is_not_equal", signature = "a, a -> bool", documentation = "x != y", declaration = "template <typename T>\nbool is_not_equal(const T& x, const T& y)" }
    , { name = "is_not_equal_by_and_by", signature = "(a -> c), (b -> c) -> (a, b -> bool)", documentation = "f(x) != g(y)", declaration = "template <typename F, typename G,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GOut = typename utils::function_traits<G>::result_type>\nstd::function<bool(const FIn& x, const GIn& y)>\n        is_not_equal_by_and_by(F f, G g)" }
    , { name = "is_not_equal_by", signature = "(a -> b) -> (a, a -> bool)", documentation = "f(x) != f(y)", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<bool(const FIn& x, const FIn& y)>\n        is_not_equal_by(F f)" }
    , { name = "is_not_equal_by_to", signature = "(a -> b), b -> a -> bool", documentation = "f(y) != x", declaration = "template <typename F, typename X,\n    typename Y = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<bool(const Y&)> is_not_equal_by_to(F f, const X& x)" }
    , { name = "is_not_equal_to", signature = "a -> a -> bool", documentation = "y != x", declaration = "template <typename X>\nstd::function<bool(const X&)> is_not_equal_to(const X& x)" }
    , { name = "is_less", signature = "a, a -> bool", documentation = "x < y", declaration = "template <typename T>\nbool is_less(const T& x, const T& y)" }
    , { name = "is_less_by_and_by", signature = "(a -> c), (b -> c) -> (a, b -> bool)", documentation = "f(x) < g(y)", declaration = "template <typename F, typename G,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GOut = typename utils::function_traits<G>::result_type>\nstd::function<bool(const FIn& x, const GIn& y)>\n        is_less_by_and_by(F f, G g)" }
    , { name = "is_less_by", signature = "(a -> b) -> (a, a -> bool)", documentation = "f(x) < f(y)", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<bool(const FIn& x, const FIn& y)>\n        is_less_by(F f)" }
    , { name = "is_less_by_than", signature = "(a -> b), b -> a -> bool", documentation = "f(y) < x", declaration = "template <typename F, typename X,\n    typename Y = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<bool(const Y&)> is_less_by_than(F f, const X& x)" }
    , { name = "is_less_than", signature = "a -> a -> bool", documentation = "y < x", declaration = "template <typename X>\nstd::function<bool(const X&)> is_less_than(const X& x)" }
    , { name = "is_less_or_equal", signature = "a, a -> bool", documentation = "x < y", declaration = "template <typename T>\nbool is_less_or_equal(const T& x, const T& y)" }
    , { name = "is_less_or_equal_by_and_by", signature = "(a -> c), (b -> c) -> (a, b -> bool)", documentation = "f(x) <= g(y)", declaration = "template <typename F, typename G,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GOut = typename utils::function_traits<G>::result_type>\nstd::function<bool(const FIn& x, const GIn& y)>\n        is_less_or_equal_by_and_by(F f, G g)" }
    , { name = "is_less_or_equal_by", signature = "(a -> b) -> (a, a -> bool)", documentation = "f(x) <= f(y)", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<bool(const FIn& x, const FIn& y)>\n        is_less_or_equal_by(F f)" }
    , { name = "is_less_or_equal_by_than", signature = "(a -> b), b -> a -> bool", documentation = "f(y) <= x", declaration = "template <typename F, typename X,\n    typename Y = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<bool(const Y&)> is_less_or_equal_by_than(F f, const X& x)" }
    , { name = "is_less_or_equal_than", signature = "a -> a -> bool", documentation = "y <= x", declaration = "template <typename X>\nstd::function<bool(const X&)> is_less_or_equal_than(const X& x)" }
    , { name = "is_greater", signature = "a, a -> bool", documentation = "x > y", declaration = "template <typename T>\nbool is_greater(const T& x, const T& y)" }
    , { name = "is_greater_by_and_by", signature = "(a -> c), (b -> c) -> (a, b -> bool)", documentation = "f(x) > g(y)", declaration = "template <typename F, typename G,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GOut = typename utils::function_traits<G>::result_type>\nstd::function<bool(const FIn& x, const GIn& y)>\n        is_greater_by_and_by(F f, G g)" }
    , { name = "is_greater_by", signature = "(a -> b) -> (a, a -> bool)", documentation = "f(x) > f(y)", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<bool(const FIn& x, const FIn& y)>\n        is_greater_by(F f)" }
    , { name = "is_greater_by_than", signature = "(a -> b), b -> a -> bool", documentation = "f(y) > x", declaration = "template <typename F, typename X,\n    typename Y = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<bool(const Y&)> is_greater_by_than(F f, const X& x)" }
    , { name = "is_greater_than", signature = "a -> a -> bool", documentation = "y > x", declaration = "template <typename X>\nstd::function<bool(const X&)> is_greater_than(const X& x)" }
    , { name = "is_greater_or_equal", signature = "a, a -> bool", documentation = "x >= y", declaration = "template <typename T>\nbool is_greater_or_equal(const T& x, const T& y)" }
    , { name = "is_greater_or_equal_by_and_by", signature = "(a -> c), (b -> c) -> (a, b -> bool)", documentation = "f(x) >= g(y)", declaration = "template <typename F, typename G,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GOut = typename utils::function_traits<G>::result_type>\nstd::function<bool(const FIn& x, const GIn& y)>\n        is_greater_or_equal_by_and_by(F f, G g)" }
    , { name = "is_greater_or_equal_by", signature = "(a -> b) -> (a, a -> bool)", documentation = "f(x) >= f(y)", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<bool(const FIn& x, const FIn& y)>\n        is_greater_or_equal_by(F f)" }
    , { name = "is_greater_or_equal_by_than", signature = "(a -> b), b -> a -> bool", documentation = "f(y) >= x", declaration = "template <typename F, typename X,\n    typename Y = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<bool(const Y&)> is_greater_or_equal_by_than(F f, const X& x)" }
    , { name = "is_greater_or_equal_than", signature = "a -> a -> bool", documentation = "y >= x", declaration = "template <typename X>\nstd::function<bool(const X&)> is_greater_or_equal_than(const X& x)" }
    , { name = "xor_bools", signature = "bool -> bool -> bool", documentation = "Exclusive or.", declaration = "template <typename T>\nbool xor_bools(const T& x, const T& y)" }
    , { name = "ord_to_eq", signature = "(a, a -> bool) -> (a, a -> bool)", documentation = "ord_to_eq((<)) == (==)", declaration = "template <typename Compare,\n    typename FIn0 = typename utils::function_traits<Compare>::template arg<0>::type,\n    typename FIn1 = typename utils::function_traits<Compare>::template arg<1>::type,\n    typename FOut = typename utils::function_traits<Compare>::result_type>\nstd::function<FOut(FIn0, FIn1)> ord_to_eq(Compare comp)" }
    , { name = "ord_to_not_eq", signature = "(a, a -> bool) -> (a, a -> bool)", documentation = "ord_to_not_eq((<)) == (!=)", declaration = "template <typename Compare,\n    typename FIn0 = typename utils::function_traits<Compare>::template arg<0>::type,\n    typename FIn1 = typename utils::function_traits<Compare>::template arg<1>::type,\n    typename FOut = typename utils::function_traits<Compare>::result_type>\nstd::function<FOut(FIn0, FIn1)> ord_to_not_eq(Compare comp)" }
    , { name = "ord_eq_to_eq", signature = "(a, a -> bool) -> (a, a -> bool)", documentation = "ord_eq_to_eq((<=)) == (==)", declaration = "template <typename Compare,\n    typename FIn0 = typename utils::function_traits<Compare>::template arg<0>::type,\n    typename FIn1 = typename utils::function_traits<Compare>::template arg<1>::type,\n    typename FOut = typename utils::function_traits<Compare>::result_type>\nstd::function<FOut(FIn0, FIn1)> ord_eq_to_eq(Compare comp)" }
    , { name = "ord_eq_to_not_eq", signature = "(a, a -> bool) -> (a, a -> bool)", documentation = "ord_eq_to_not_eq((<=)) == (!=)", declaration = "template <typename Compare,\n    typename FIn0 = typename utils::function_traits<Compare>::template arg<0>::type,\n    typename FIn1 = typename utils::function_traits<Compare>::template arg<1>::type,\n    typename FOut = typename utils::function_traits<Compare>::result_type>\nstd::function<FOut(FIn0, FIn1)> ord_eq_to_not_eq(Compare comp)" }
    , { name = "bind_1st_of_2", signature = "(a, b -> c), a -> (b -> c)", documentation = "Bind first parameter or binary function.", declaration = "template <typename F, typename T,\n    typename FIn0 = typename utils::function_traits<F>::template arg<0>::type,\n    typename FIn1 = typename utils::function_traits<F>::template arg<1>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<FOut(FIn1)> bind_1st_of_2(F f, T x)" }
    , { name = "bind_1st_of_3", signature = "(a, b, c -> d), a -> (b, c -> d)", documentation = "Bind first parameter of ternary function.", declaration = "template <typename F, typename X,\n    typename FIn0 = typename utils::function_traits<F>::template arg<0>::type,\n    typename FIn1 = typename utils::function_traits<F>::template arg<1>::type,\n    typename FIn2 = typename utils::function_traits<F>::template arg<2>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<FOut(FIn1, FIn2)> bind_1st_of_3(F f, X x)" }
    , { name = "bind_1st_and_2nd_of_3", signature = "(a, b, c -> d), a, b -> (c -> d)", documentation = "Bind first and second parameter of ternary function.", declaration = "template <typename F, typename X, typename Y,\n    typename FIn0 = typename utils::function_traits<F>::template arg<0>::type,\n    typename FIn1 = typename utils::function_traits<F>::template arg<1>::type,\n    typename FIn2 = typename utils::function_traits<F>::template arg<2>::type,\n    typename FOut = typename utils::function_traits<F>::result_type>\nstd::function<FOut(FIn2)> bind_1st_and_2nd_of_3(F f, X x, Y y)" }
    , { name = "flip", signature = "(a -> b) -> (b -> a)", documentation = "Flips the arguments of a binary function", declaration = "template <typename F,\n    typename A = typename utils::function_traits<F>::template arg<0>::type,\n    typename B = typename utils::function_traits<F>::template arg<1>::type,\n    typename C = typename utils::function_traits<F>::result_type>\nstd::function<C(B, A)> flip(F f)" }
    , { name = "apply_to_pair", signature = "(a, b -> c) -> (a, b) -> c", documentation = "Apply binary function to parts of a pair.", declaration = "template <typename F,\n    typename FIn0 = typename utils::function_traits<F>::template arg<0>::type,\n    typename FIn1 = typename utils::function_traits<F>::template arg<1>::type,\n    typename FuncRes = typename utils::function_traits<F>::result_type,\n    typename ResFunc = typename std::function<FuncRes(const std::pair<FIn0, FIn1>&)>>\nResFunc apply_to_pair(F f)" }
    , { name = "compose", signature = "(a -> b), (b -> c) -> (a -> c)", documentation = "Forward composition: compose(f, g)(x) = g(f(x))", declaration = "template <typename F, typename G,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename GOut = typename utils::function_traits<G>::result_type>\nstd::function<GOut(FIn)> compose(F f, G g)" }
    , { name = "forward_apply", signature = "a, (a -> b) -> b", documentation = "Forward application.", declaration = "template <typename X, typename F,\n    typename FOut = typename utils::function_traits<F>::result_type>\nFOut forward_apply(const X& x, F f)" }
    , { name = "compose", signature = "(a -> b), (b -> c), (c -> d) -> (a -> d)", documentation = "Forward composition: compose(f, g, h)(x) = h(g(f(x)))", declaration = "template <typename F, typename G, typename H,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename GOut = typename utils::function_traits<G>::result_type,\n    typename HIn = typename utils::function_traits<H>::template arg<0>::type,\n    typename HOut = typename utils::function_traits<H>::result_type>\nstd::function<HOut(FIn)> compose(F f, G g, H h)" }
    , { name = "compose", signature = "(a -> b), (b -> c), (c -> d), (d -> e) -> (a -> e)", documentation = "Forward composition: compose(f, g, h, i)(x) = i(h(g(f(x))))", declaration = "template <typename F, typename G, typename H, typename I,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename GOut = typename utils::function_traits<G>::result_type,\n    typename HIn = typename utils::function_traits<H>::template arg<0>::type,\n    typename HOut = typename utils::function_traits<H>::result_type,\n    typename IIn = typename utils::function_traits<I>::template arg<0>::type,\n    typename IOut = typename utils::function_traits<I>::result_type>\nstd::function<IOut(FIn)> compose(F f, G g, H h, I i)" }
    , { name = "compose", signature = "(a -> b), (b -> c), (c -> d), (d -> e), (e -> f) -> (a -> f)", documentation = "Forward composition: compose(f, g, h, i, j)(x) = j(i(h(g(f(x)))))", declaration = "template <typename F, typename G, typename H, typename I, typename J,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename GIn = typename utils::function_traits<G>::template arg<0>::type,\n    typename GOut = typename utils::function_traits<G>::result_type,\n    typename HIn = typename utils::function_traits<H>::template arg<0>::type,\n    typename HOut = typename utils::function_traits<H>::result_type,\n    typename IIn = typename utils::function_traits<I>::template arg<0>::type,\n    typename IOut = typename utils::function_traits<I>::result_type,\n    typename JIn = typename utils::function_traits<I>::template arg<0>::type,\n    typename JOut = typename utils::function_traits<I>::result_type>\nstd::function<JOut(FIn)> compose(F f, G g, H h, I i, J j)" }
    , { name = "logical_not", signature = "(a -> bool) -> (a -> bool)", documentation = "logical_not(f) = \\x -> !x", declaration = "template <typename UnaryPredicate,\n    typename X = typename utils::function_traits<UnaryPredicate>::template arg<0>::type>\nstd::function<bool(X)> logical_not(UnaryPredicate f)" }
    , { name = "logical_or", signature = "(a -> bool), (a -> bool) -> (a -> bool)", documentation = "logical_or(f, g) = \\x -> f(x) or g(x)", declaration = "template <typename UnaryPredicateF, typename UnaryPredicateG,\n    typename X = typename utils::function_traits<UnaryPredicateF>::template arg<0>::type,\n    typename Y = typename utils::function_traits<UnaryPredicateG>::template arg<0>::type>\nstd::function<bool(X)> logical_or(UnaryPredicateF f, UnaryPredicateG g)" }
    , { name = "logical_and", signature = "(a -> bool), (a -> bool) -> (a -> bool)", documentation = "logical_and(f, g) = \\x -> f(x) and g(x)", declaration = "template <typename UnaryPredicateF, typename UnaryPredicateG,\n    typename X = typename utils::function_traits<UnaryPredicateF>::template arg<0>::type,\n    typename Y = typename utils::function_traits<UnaryPredicateG>::template arg<0>::type>\nstd::function<bool(X)> logical_and(UnaryPredicateF f, UnaryPredicateG g)" }
    , { name = "logical_xor", signature = "(a -> bool), (a -> bool) -> (a -> bool)", documentation = "logical_xor(f, g) = \\x -> f(x) xor g(x)", declaration = "template <typename UnaryPredicateF, typename UnaryPredicateG,\n    typename X = typename utils::function_traits<UnaryPredicateF>::template arg<0>::type,\n    typename Y = typename utils::function_traits<UnaryPredicateG>::template arg<0>::type>\nstd::function<bool(X)> logical_xor(UnaryPredicateF f, UnaryPredicateG g)" }
    , { name = "is_empty", signature = "[a] -> bool", documentation = "is_empty([1, 2]) == false", declaration = "template <typename Container>\nbool is_empty(const Container& xs)" }
    , { name = "is_not_empty", signature = "[a] -> bool", documentation = "is_not_empty([1, 2]) == true", declaration = "template <typename Container>\nbool is_not_empty(const Container& xs)" }
    , { name = "size_of_cont", signature = "[a] -> int", documentation = "size_of_cont([3, 4]) == 2", declaration = "template <typename Container>\nstd::size_t size_of_cont(const Container& xs)" }
    , { name = "convert", signature = "a -> b", documentation = "Converts one type of element to another.", declaration = "template <typename Dest, typename Source>\nDest convert(const Source& x)" }
    , { name = "convert_elems", signature = "[a] -> [b]", documentation = "convert_elems<NewT>([1, 2, 3]) == [NewT(1), NewT(2), NewT(3)]", declaration = "template <typename NewT, typename ContainerIn,\n    typename ContainerOut = typename same_cont_new_t<ContainerIn, NewT>::type>\nContainerOut convert_elems(const ContainerIn& xs)" }
    , { name = "convert_container", signature = "[a] -> [a]", documentation = "convert_container([1, 2, 3]) == [1, 2, 3]\nUseful for example if you want to convert an std::list to an std::vector.", declaration = "template <typename ContainerOut, typename ContainerIn>\nContainerOut convert_container(const ContainerIn& xs)" }
    , { name = "convert_container_and_elems", signature = "[a] -> [b]", documentation = "Converts between different containers and elements.\nDest elements are allowed to have explicit constructors.\nconvert([1, 2, 3]) == [1, 2, 3]", declaration = "template <typename ContainerOut, typename ContainerIn>\nContainerOut convert_container_and_elems(const ContainerIn& xs)" }
    , { name = "get_range", signature = "int, int, [a] -> [a]", documentation = "get_range(2, 5, [0,1,2,3,4,5,6,7,8]) == [2,3,4]", declaration = "template <typename Container>\nContainer get_range\n        (std::size_t idxBegin, std::size_t idxEnd, const Container& xs)" }
    , { name = "set_range", signature = "int, [a], [a] -> [a]", documentation = "set_range(2, [9,9,9], [0,1,2,3,4,5,6,7,8]) == [0,1,9,9,9,5,6,7,8]", declaration = "template <typename Container>\nContainer set_range\n        (std::size_t idxBegin, const Container& token, const Container& xs)" }
    , { name = "remove_range", signature = "int, int, [a] -> [a]", documentation = "remove_range(2, 5, [0,1,2,3,4,5,6,7]) == [0,1,5,6,7]", declaration = "template <typename Container>\nContainer remove_range\n        (std::size_t idxBegin, std::size_t idxEnd, const Container& xs)" }
    , { name = "insert_at", signature = "int, [a], [a] -> [a]", documentation = "insert_at(2, [8,9], [0,1,2,3,4]) == [0,1,8,9,2,3,4]", declaration = "template <typename Container>\nContainer insert_at(std::size_t idxBegin,\n        const Container& token, const Container& xs)" }
    , { name = "replace_range", signature = "int, [a], [a] -> [a]", documentation = "replace_range(2, [8,9], [0,1,2,3,4]) == [0,1,8,9,4]", declaration = "template <typename Container>\nContainer replace_range(std::size_t idxBegin,\n        const Container& token, const Container& xs)" }
    , { name = "elem_at_idx", signature = "int, [a] -> [a]", documentation = "elem_at_idx(2, [7,6,5,4,3]) == 5", declaration = "template <typename Container,\n    typename T = typename Container::value_type>\nT elem_at_idx(std::size_t idx, const Container& xs)" }
    , { name = "elems_at_idxs", signature = "[int], [a] -> [a]", documentation = "elem_at_idxs([1, 3], [7,6,5,4,3]) == [6, 4]", declaration = "template <typename Container,\n    typename ContainerIdxs,\n    typename T = typename Container::value_type,\n    typename ContainerOut = std::vector<T>>\nstd::vector<T> elems_at_idxs(const ContainerIdxs& idxs, const Container& xs)" }
    , { name = "nth_element", signature = "int -> [a] -> a", documentation = "nth_element(2)([5,6,7,8]) == 7", declaration = "template <typename Container,\n        typename T = typename Container::value_type>\nstd::function<T(const Container& xs)> nth_element(std::size_t n)" }
    , { name = "nth_element_flipped", signature = "[a] -> int -> a", documentation = "nth_element_flipped([5,6,7,8])(2) == 7\nCan be used to erase outer container type.", declaration = "template <typename Container,\n        typename T = typename Container::value_type>\nstd::function<T(std::size_t n)> nth_element_flipped(const Container& xs)" }
    , { name = "transform", signature = "(a -> b), [a] -> [b]", documentation = "transform((*2), [1, 3, 4]) == [2, 6, 8]\nAlso known as map.", declaration = "template <typename F, typename ContainerIn,\n    typename ContainerOut = typename same_cont_new_t_from_unary_f<ContainerIn, F>::type>\nContainerOut transform(F f, const ContainerIn& xs)" }
    , { name = "reverse", signature = "[a] -> [a]", documentation = "reverse([0,4,2,6]) == [6,2,4,0]", declaration = "template <typename Container>\nContainer reverse(const Container& xs)" }
    , { name = "take", signature = "int, [a] -> [a]", documentation = "take(3, [0,1,2,3,4,5,6,7]) == [0,1,2]\ntake(10, [0,1,2]) == [0,1,2]", declaration = "template <typename Container>\nContainer take(std::size_t amount, const Container& xs)" }
    , { name = "drop", signature = "int, [a] -> [a]", documentation = "drop(3, [0,1,2,3,4,5,6,7]) == [3,4,5,6,7]", declaration = "template <typename Container>\nContainer drop(std::size_t amount, const Container& xs)" }
    , { name = "fold_left", signature = "(a, b -> a), a, [b] -> a", documentation = "fold_left((+), 0, [1, 2, 3]) == ((0+1)+2)+3 == 6\nTakes the second argument and the first item of the list\nand applies the function to them,\nthen feeds the function with this result and the second argument and so on.", declaration = "template <typename F, typename Container,\n    typename Acc = typename utils::function_traits<F>::template arg<0>::type>\nAcc fold_left(F f, const Acc& init, const Container& xs)" }
    , { name = "fold_left", signature = "(a, a -> a), [a] -> a", documentation = "fold_left_1((+), [1, 2, 3]) == (1+2)+3 == 6\nTakes the first 2 items of the list and applies the function to them,\nthen feeds the function with this result and the third argument and so on.", declaration = "template <typename F, typename Container,\n    typename Acc = typename Container::value_type>\nAcc fold_left_1(F f, const Container& xs)" }
    , { name = "fold_right", signature = "(a, b -> b), b, [a] -> b", documentation = "fold_right((+), 0, [1, 2, 3]) == 1+(2+(3+0)) == 6\nTakes the second argument and the last item of the list\nand applies the function,\nthen it takes the penultimate item from the end and the result, and so on.", declaration = "template <typename F, typename Container,\n    typename Acc = typename utils::function_traits<F>::template arg<1>::type>\nAcc fold_right(F f, const Acc& init, const Container& xs)" }
    , { name = "fold_right_1", signature = "(a, a -> a), [a] -> a", documentation = "fold_right_1((+), [1, 2, 3]) == 1+(2+3)) == 6\nTakes the last two items of the list and applies the function,\nthen it takes the third item from the end and the result, and so on.", declaration = "template <typename F, typename Container,\n    typename Acc = typename Container::value_type>\nAcc fold_right_1(F f, const Container& xs)" }
    , { name = "scan_left", signature = "(a, b -> a), a, [b] -> [a]", documentation = "scan_left((+), 0, [1, 2, 3]) == [0, 1, 3, 6]\nTakes the second argument and the first item of the list\nand applies the function to them,\nthen feeds the function with this result and the second argument and so on.\nIt returns the list of intermediate and final results.", declaration = "template <typename F, typename ContainerIn,\n    typename Acc = typename utils::function_traits<F>::template arg<0>::type,\n    typename ContainerOut = typename same_cont_new_t<ContainerIn, Acc>::type>\nContainerOut scan_left(F f, const Acc& init, const ContainerIn& xs)" }
    , { name = "scan_left_1", signature = "(a, a -> a), [a] -> [a]", documentation = "scan_left_1((+), [1, 2, 3]) == [1, 3, 6]\nTakes the first 2 items of the list and applies the function to them,\nthen feeds the function with this result and the third argument and so on.\nIt returns the list of intermediate and final results.", declaration = "template <typename F, typename ContainerIn,\n    typename Acc = typename ContainerIn::value_type,\n    typename ContainerOut = typename same_cont_new_t<ContainerIn, Acc>::type>\nContainerOut scan_left_1(F f, const ContainerIn& xs)" }
    , { name = "scan_right", signature = "(a, b -> b), b, [a] -> [b]", documentation = "scan_right((+), 0, [1, 2, 3]) == [6, 5, 3, 0]\nTakes the second argument and the last item of the list\nand applies the function,\nthen it takes the penultimate item from the end and the result, and so on.\nIt returns the list of intermediate and final results.", declaration = "template <typename F, typename ContainerIn,\n    typename Acc = typename utils::function_traits<F>::template arg<1>::type,\n    typename ContainerOut = typename same_cont_new_t<ContainerIn, Acc>::type>\nContainerOut scan_right(F f, const Acc& init, const ContainerIn& xs)" }
    , { name = "scan_right_1", signature = "(a, a -> a), [a] -> [a]", documentation = "scan_right_1((+), [1, 2, 3]) == [1, 3, 6]\nTakes the last two items of the list and applies the function,\nthen it takes the third item from the end and the result, and so on.\nIt returns the list of inntermediate and final results.", declaration = "template <typename F, typename ContainerIn,\n    typename Acc = typename ContainerIn::value_type,\n    typename ContainerOut = typename same_cont_new_t<ContainerIn, Acc>::type>\nContainerOut scan_right_1(F f, const ContainerIn& xs)" }
    , { name = "sum", signature = "[a] -> a", documentation = "sum([1, 2, 3]) == 7", declaration = "template <typename Container>\ntypename Container::value_type sum(const Container& xs)" }
    , { name = "append", signature = "[a], [a] -> [a]", documentation = "append([1, 2], [3, 4, 5]) == [1, 2, 3, 4, 5]", declaration = "template <typename Container>\nContainer append(const Container& xs, const Container& ys)" }
    , { name = "concat", signature = "[[a]] -> [a]", documentation = "concat([[1, 2], [], [3]]) == [1, 2, 3]\nalso known as flatten", declaration = "template <typename ContainerIn,\n    typename ContainerOut = typename ContainerIn::value_type>\nContainerOut concat(const ContainerIn& xss)" }
    , { name = "interweave", signature = "[a], [a] -> [a]", documentation = "Return a list that contains elements from the two provided,\nin alternate order. If one list runs out of items,\nappend the items from the remaining list.\ninterweave([1,3], [2,4]) == [1,2,3,4]\ninterweave([1,3,5,7], [2,4]) == [1,2,3,4,5,7]", declaration = "template <typename Container>\nContainer interweave(const Container& xs, const Container& ys)" }
    , { name = "unweave", signature = "[a] -> ([a], [a])", documentation = "Puts the elements with an even index into the first list,\nand the elements with an odd index into the second list.\nInverse of interweave.\nunweave([0,1,2,3]) == ([0,2], [1,3])\nunweave([0,1,2,3,4]) == ([0,2,4], [1,3])", declaration = "template <typename Container>\nstd::pair<Container, Container> unweave(const Container& xs)" }
    , { name = "sort_by", signature = "(a, a -> bool), [a] -> [a]", documentation = "sort by given less comparator", declaration = "template <typename Compare, typename Container>\nContainer sort_by(Compare comp, const Container& xs)" }
    , { name = "sort_on", signature = "(a -> b), [a] -> [a]", documentation = "sort by given transformer", declaration = "template <typename F, typename Container>\nContainer sort_on(F f, const Container& xs)" }
    , { name = "sort", signature = "[a] -> [a]", documentation = "sort by std::less", declaration = "template <typename Container>\nContainer sort(const Container& xs)" }
    , { name = "unique_by", signature = "(a, a -> bool), [a] -> [a]", documentation = "Like unique but with user supplied equality predicate.", declaration = "template <typename Container, typename BinaryPredicate>\nContainer unique_by(BinaryPredicate p, const Container& xs)" }
    , { name = "unique_on", signature = "(a -> b), [a] -> [a]", documentation = "Like unique but with user supplied transformation (e.g. getter).", declaration = "template <typename Container, typename F>\nContainer unique_on(F f, const Container& xs)" }
    , { name = "unique", signature = "[a] -> [a]", documentation = "unique([1,2,2,3,2]) == [1,2,3,2]", declaration = "template <typename Container>\nContainer unique(const Container& xs)" }
    , { name = "intersperse", signature = "a, [a] -> [a]", documentation = "intersperse(0, [1, 2, 3]) == [1, 0, 2, 0, 3]", declaration = "template <typename Container,\n    typename X = typename Container::value_type>\nContainer intersperse(const X& value, const Container& xs)" }
    , { name = "join", signature = "[a], [[a]] -> [a]", documentation = "Also known as Intercalate.\njoin([0, 0], [[1], [2], [3, 4]]) == [1, 0, 0, 2, 0, 0, 3, 4]", declaration = "template <typename Container,\n    typename X = typename Container::value_type>\nX join(const X& separator, const Container& xs)" }
    , { name = "is_elem_of_by", signature = "(a -> bool), [a] -> bool", documentation = "is_elem_of_by((==), [1,2,3]) == true", declaration = "template <typename UnaryPredicate, typename Container>\nbool is_elem_of_by(UnaryPredicate pred, const Container& xs)" }
    , { name = "is_elem_of", signature = "a, [a] -> bool", documentation = "is_elem_of(2, [1,2,3]) == true", declaration = "template <typename Container>\nbool is_elem_of(const typename Container::value_type& x, const Container& xs)" }
    , { name = "nub_by", signature = "(a, a -> bool), [a] -> [a]", documentation = "nub_by((==), [1,2,2,3,2]) == [1,2,3]", declaration = "template <typename Container, typename BinaryPredicate>\nContainer nub_by(BinaryPredicate p, const Container& xs)" }
    , { name = "nub_on", signature = "(a -> b), [a] -> [a]", documentation = "nub_on((mod 10), [12,32,15]) == [12,15]", declaration = "template <typename Container, typename F>\nContainer nub_on(F f, const Container& xs)" }
    , { name = "nub", signature = "[a] -> [a]", documentation = "nub([1,2,2,3,2]) == [1,2,3]", declaration = "template <typename Container>\nContainer nub(const Container& xs)" }
    , { name = "all_unique_by_eq", signature = "(a, a -> bool), [a] -> bool", documentation = "Returns true for empty containers.\nO(n^2)", declaration = "template <typename Container, typename BinaryPredicate>\nbool all_unique_by_eq(BinaryPredicate p, const Container& xs)" }
    , { name = "all_unique_on", signature = "(a -> b), [a] -> bool", documentation = "Returns true for empty containers.\nO(n^2)", declaration = "template <typename Container, typename F>\nbool all_unique_on(F f, const Container& xs)" }
    , { name = "all_unique", signature = "[a] -> bool", documentation = "Returns true for empty containers.\nO(n^2)", declaration = "template <typename Container>\nbool all_unique(const Container& xs)" }
    , { name = "is_strictly_sorted_by", signature = "(a, a -> bool) -> [a] -> bool", documentation = "comp(a, b) must return true only if a < b.\nO(n)", declaration = "template <typename Container, typename Compare>\nbool is_strictly_sorted_by(Compare comp, const Container& xs)" }
    , { name = "is_strictly_sorted_by", signature = "(a -> b) -> [a] -> bool", documentation = "O(n)", declaration = "template <typename Container, typename F>\nbool is_strictly_sorted_on(F f, const Container& xs)" }
    , { name = "is_strictly_sorted", signature = "[a] -> bool", documentation = "O(n)", declaration = "template <typename Container>\nbool is_strictly_sorted(const Container& xs)" }
    , { name = "is_sorted_by", signature = "(a, a -> bool), [a] -> bool", documentation = "comp(a, b) must return true only if a < b.\nO(n)", declaration = "template <typename Container, typename Compare>\nbool is_sorted_by(Compare comp, const Container& xs)" }
    , { name = "is_sorted_on", signature = "(a -> b), [a] -> bool", documentation = "O(n)", declaration = "template <typename Container, typename F>\nbool is_sorted_on(F f, const Container& xs)" }
    , { name = "is_sorted", signature = "[a] -> bool", documentation = "O(n)", declaration = "template <typename Container>\nbool is_sorted(const Container& xs)" }
    , { name = "is_prefix_of", signature = "[a] -> [a] -> bool", documentation = "is_prefix_of(\"Fun\", \"FunctionalPlus\") == true", declaration = "template <typename Container>\nbool is_prefix_of(const Container& token, const Container& xs)" }
    , { name = "is_suffix_of", signature = "[a] -> [a] -> bool", documentation = "is_suffix_of(\"us\", \"FunctionalPlus\") == true", declaration = "template <typename Container>\nbool is_suffix_of(const Container& token, const Container& xs)" }
    , { name = "all_by", signature = "(a -> bool), [a] -> bool", documentation = "all_by(is_even, [2, 4, 6]) == true\nReturns true for empty containers.", declaration = "template <typename UnaryPredicate, typename Container>\nbool all_by(UnaryPredicate p, const Container& xs)" }
    , { name = "all", signature = "[bool] -> bool", documentation = "all([true, false, true]) == false\nReturns true for empty containers.", declaration = "template <typename Container>\nbool all(const Container& xs)" }
    , { name = "all_the_same_by", signature = "(a, a -> bool), [a] -> bool", documentation = "Returns true for empty containers.", declaration = "template <typename Container, typename BinaryPredicate>\nbool all_the_same_by(BinaryPredicate p, const Container& xs)" }
    , { name = "all_the_same_on", signature = "(a -> bool), [a] -> bool", documentation = "Returns true for empty containers.", declaration = "template <typename Container, typename F>\nbool all_the_same_on(F f, const Container& xs)" }
    , { name = "all_the_same", signature = "[a] -> bool", documentation = "Returns true for empty containers.", declaration = "template <typename Container>\nbool all_the_same(const Container& xs)" }
    , { name = "generate_range_step", signature = "a, a, a -> [a]", documentation = "generate_range_step(2, 9, 2) == [2, 4, 6, 8]", declaration = "template <typename ContainerOut, typename T>\nContainerOut generate_range_step\n        (const T start, const T end, const T step)" }
    , { name = "generate_range", signature = "a, a -> [a]", documentation = "generate_range(2, 9) == [2, 3, 4, 5, 6, 7, 8]", declaration = "template <typename ContainerOut, typename T>\nContainerOut generate_range(const T start, const T end)" }
    , { name = "all_idxs", signature = "[a] -> [int]", documentation = "all_idxs([6,4,7,6]) == [0,1,2,3]", declaration = "template <typename Container>\nstd::vector<std::size_t> all_idxs(const Container& xs)" }
    , { name = "init", signature = "[a] -> [a]", documentation = "init([0,1,2,3]) == [0,1,2]", declaration = "template <typename Container>\nContainer init(const Container& xs)" }
    , { name = "tail", signature = "[a] -> [a]", documentation = "tail([0,1,2,3]) == [1,2,3]", declaration = "template <typename Container>\nContainer tail(const Container& xs)" }
    , { name = "any_by", signature = "(a -> bool), [a] -> bool", documentation = "any_by(is_odd, [2, 4, 6]) == false", declaration = "template <typename UnaryPredicate, typename Container>\nbool any_by(UnaryPredicate p, const Container& xs)" }
    , { name = "any", signature = "[bool] -> bool", documentation = "any([false, true, false]) == true", declaration = "template <typename Container>\nbool any(const Container& xs)" }
    , { name = "none_by", signature = "(a -> bool), [a] -> bool", documentation = "none_by(is_even, [3, 4, 5]) == false", declaration = "template <typename UnaryPredicate, typename Container>\nbool none_by(UnaryPredicate p, const Container& xs)" }
    , { name = "none", signature = "[bool] -> bool", documentation = "none([false, true, false]) == false", declaration = "template <typename Container>\nbool none(const Container& xs)" }
    , { name = "minimum_by", signature = "(a, a -> bool) -> [a] -> a", documentation = "minimum_by(lessLength, [\"123\", \"12\", \"1234\", \"123\"]) -> \"12\"", declaration = "template <typename Compare, typename Container>\ntypename Container::value_type minimum_by(Compare comp,\n        const Container& xs)" }
    , { name = "maximum_by", signature = "(a, a -> bool) -> [a] -> a", documentation = "maximum_by(lessLength, [\"123\", \"12\", \"1234\", \"123\"]) == \"1234\"", declaration = "template <typename Compare, typename Container>\ntypename Container::value_type maximum_by(Compare comp,\n        const Container& xs)" }
    , { name = "minimum_on", signature = "(a -> b) -> [a] -> a", documentation = "minimum_on(length, [\"123\", \"12\", \"1234\", \"123\"]) -> \"12\"", declaration = "template <typename F, typename Container>\ntypename Container::value_type minimum_on(F f, const Container& xs)" }
    , { name = "maximum_on", signature = "(a -> b) -> [a] -> a", documentation = "maximum_on(length, [\"123\", \"12\", \"1234\", \"123\"]) == \"1234\"", declaration = "template <typename F, typename Container>\ntypename Container::value_type maximum_on(F f, const Container& xs)" }
    , { name = "minimum", signature = "[a] -> a", documentation = "minimum([3, 1, 4, 2]) == 1", declaration = "template <typename Container>\ntypename Container::value_type minimum(const Container& xs)" }
    , { name = "maximum", signature = "[a] -> a", documentation = "maximum([3, 1, 4, 2]) == 4", declaration = "template <typename Container>\ntypename Container::value_type maximum(const Container& xs)" }
    , { name = "minimum_idx_by", signature = "[a] -> int", documentation = "minimum_idx_by(lessLength, [\"123\", \"12\", \"1234\", \"123\"]) -> \"1\"\nreturn index of first minimum element", declaration = "template <typename Compare, typename Container>\ntypename Container::value_type minimum_idx_by(Compare comp,\n        const Container& xs)" }
    , { name = "maximum_idx_by", signature = "[a] -> int", documentation = "maximum_idx_by(lessLength, [\"123\", \"12\", \"1234\", \"123\"]) == \"2\"\nreturn index of first maximum element", declaration = "template <typename Compare, typename Container>\ntypename Container::value_type maximum_idx_by(Compare comp,\n        const Container& xs)" }
    , { name = "minimum_idx_on", signature = "(a -> b), [a] -> int", documentation = "minimum_idx_on(length, [\"123\", \"12\", \"1234\", \"123\"]) -> \"1\"\nreturn index of first minimum element", declaration = "template <typename F, typename Container>\ntypename Container::value_type minimum_idx_on(F f, const Container& xs)" }
    , { name = "maximum_idx_on", signature = "(a -> b), [a] -> int", documentation = "maximum_idx_on(length, [\"123\", \"12\", \"1234\", \"123\"]) == \"2\"\nreturn index of first maximum element", declaration = "template <typename F, typename Container>\ntypename Container::value_type maximum_idx_on(F f, const Container& xs)" }
    , { name = "minimum_idx", signature = "[a] -> int", documentation = "minimum_idx([3, 1, 4, 2]) == 1\nreturn index of first minimum element", declaration = "template <typename Container>\ntypename Container::value_type minimum_idx(const Container& xs)" }
    , { name = "maximum_idx", signature = "[a] -> int", documentation = "maximum_idx([3, 1, 4, 2]) == 2\nreturn index of first maximum element", declaration = "template <typename Container>\ntypename Container::value_type maximum_idx(const Container& xs)" }
    , { name = "mean", signature = "[a] -> a", documentation = "mean([1, 4, 4]) == 3\nunsafe! Make sure sum(xs) does not overflow. see mean_using_doubles", declaration = "template <typename Result, typename Container>\nResult mean(const Container& xs)" }
    , { name = "mean_using_doubles", signature = "[a] -> a", documentation = "mean_using_doubles([1, 4, 4]) == 3\nConverts elements to double before calculating the sum to prevent overflows.", declaration = "template <typename Result, typename Container>\nResult mean_using_doubles(const Container& xs)" }
    , { name = "median", signature = "[a] -> a", documentation = "median([5, 6, 4, 3, 2, 6, 7, 9, 3]) == 5", declaration = "template <typename Container,\n        typename Result = typename Container::value_type>\nResult median(const Container& xs)" }
    , { name = "all_unique_by_less", signature = "(a, a -> bool), [a] -> bool", documentation = "Returns true for empty containers.\nO(n*log(n))", declaration = "template <typename Container, typename Compare>\nbool all_unique_by_less(Compare comp, const Container& xs)" }
    , { name = "all_unique_less", signature = "[a] -> bool", documentation = "Returns true for empty containers.\nO(n*log(n))", declaration = "template <typename Container>\nbool all_unique_less(const Container& xs)" }
    , { name = "is_infix_of", signature = "[a], [a] -> bool", documentation = "is_infix_of(\"ion\", \"FunctionalPlus\") == true", declaration = "template <typename Container>\nbool is_infix_of(const Container& token, const Container& xs)" }
    , { name = "is_subsequence_of", signature = "[a], [a] -> bool", documentation = "is_subsequence_of(\"Final\", \"FunctionalPlus\") == true", declaration = "template <typename Container>\nbool is_subsequence_of(const Container& seq, const Container& xs)" }
    , { name = "count_if", signature = "(a -> bool), [a] -> int", documentation = "count_if(is_even, [1, 2, 3, 5, 7, 8]) == 2", declaration = "template <typename UnaryPredicate, typename Container>\nstd::size_t count_if(UnaryPredicate p, const Container& xs)" }
    , { name = "count", signature = "a, [a] -> int", documentation = "count(2, [1, 2, 3, 5, 7, 2, 2]) == 3", declaration = "template <typename Container>\nstd::size_t count\n        (const typename Container::value_type& x, const Container& xs)" }
    , { name = "keep_if", signature = "(a -> bool), [a] -> [a]", documentation = "keep_if(is_even, [1, 2, 3, 2, 4, 5]) == [2, 2, 4]\nAlso known as filter.", declaration = "template <typename Pred, typename Container>\nContainer keep_if(Pred pred, const Container& xs)" }
    , { name = "drop_if", signature = "(a -> bool), [a] -> [a]", documentation = "drop_if(is_even, [1, 2, 3, 2, 4, 5]) == [1, 3, 5]\nAlso known as reject.", declaration = "template <typename Pred, typename Container>\nContainer drop_if(Pred pred, const Container& xs)" }
    , { name = "without", signature = "a, [a] -> [a]", documentation = "without(0, [1, 0, 0, 5, 3, 0, 1]) == [1, 5, 3, 1]", declaration = "template <typename Container,\n    typename T = typename Container::value_type>\nContainer without(T elem, const Container& xs)" }
    , { name = "keep_if_with_idx", signature = "(int, a -> bool), [a] -> [a]", documentation = "Predicate takes index and value.\nAll elements fulfilling the predicate are kept.", declaration = "template <typename Pred, typename Container>\nContainer keep_if_with_idx(Pred pred, const Container& xs)" }
    , { name = "drop_if_with_idx", signature = "(int, a -> bool), [a] -> [a]", documentation = "Predicate takes index and value.\nAll elements fulfilling the predicate are skipped.", declaration = "template <typename Pred, typename Container>\nContainer drop_if_with_idx(Pred pred, const Container& xs)" }
    , { name = "keep_by_idx", signature = "(int -> bool), [a] -> [a]", documentation = "Predicate takes an index and decides if an element is kept.", declaration = "template <typename UnaryPredicate, typename Container>\nContainer keep_by_idx(UnaryPredicate pred, const Container& xs)" }
    , { name = "drop_by_idx", signature = "(int -> bool), [a] -> [a]", documentation = "Predicate takes an index and decides if an element is dropped.", declaration = "template <typename UnaryPredicate, typename Container>\nContainer drop_by_idx(UnaryPredicate pred, const Container& xs)" }
    , { name = "keep_idxs", signature = "[int], [a] -> [a]", documentation = "keep_idxs([2,5], [1,2,3,4,5,6,7]) == [3,6]", declaration = "template <typename ContainerIdxs, typename Container>\nContainer keep_idxs(const ContainerIdxs& idxs_to_keep, const Container& xs)" }
    , { name = "drop_idxs", signature = "[int], [a] -> [a]", documentation = "drop_idxs([2,5], [1,2,3,4,5,6,7]) == [1,2,4,5,7]", declaration = "template <typename ContainerIdxs, typename Container>\nContainer drop_idxs(const ContainerIdxs& idxs_to_drop, const Container& xs)" }
    , { name = "justs", signature = "[maybe a] -> [a]", documentation = "From a Container filled with Maybe<T> the nothings are dropped\nand the values inside the justs are returned in a new container.", declaration = "template <typename ContainerIn,\n    typename ContainerOut =\n        typename same_cont_new_t<ContainerIn,\n            typename ContainerIn::value_type::type>::type>\nContainerOut justs(const ContainerIn& xs)" }
    , { name = "oks", signature = "[result a b] -> [a]", documentation = "From a Container filled with Result<Ok, Error> the errors are dropped\nand the values inside the ok are returned in a new container.", declaration = "template <typename ContainerIn,\n    typename ContainerOut =\n        typename same_cont_new_t<ContainerIn,\n            typename ContainerIn::value_type::ok_t>::type>\nContainerOut oks(const ContainerIn& xs)" }
    , { name = "errors", signature = "[result a b] -> [b]", documentation = "From a Container filled with Result<Ok, Error> the oks are dropped\nand the values inside the errors are returned in a new container.", declaration = "template <typename ContainerIn,\n    typename ContainerOut =\n        typename same_cont_new_t<ContainerIn,\n            typename ContainerIn::value_type::error_t>::type>\nContainerOut errors(const ContainerIn& xs)" }
    , { name = "trim_left_by", signature = "(a -> bool), [a] -> [a]", documentation = "trim_left_by(is_even, [0,2,4,5,6,7,8,6,4]) == [5,6,7,8,6,4]", declaration = "template <typename Container, typename UnaryPredicate>\nContainer trim_left_by(UnaryPredicate p, const Container& xs)" }
    , { name = "trim_left", signature = "a, [a] -> [a]", documentation = "trim_left(0, [0,0,0,5,6,7,8,6,4]) == [5,6,7,8,6,4]", declaration = "template <typename Container,\n        typename T = typename Container::value_type>\nContainer trim_left(const T& x, const Container& xs)" }
    , { name = "trim_token_left", signature = "[a], [a] -> [a]", documentation = "trim_token_left([0,1,2], [0,1,2,0,1,2,7,5,9]) == [7,5,9]", declaration = "template <typename Container>\nContainer trim_token_left(const Container& token, const Container& xs)" }
    , { name = "trim_right_by", signature = "(a -> bool), [a] -> [a]", documentation = "trim_right_by(is_even, [0,2,4,5,6,7,8,6,4]) == [0,2,4,5,6,7]", declaration = "template <typename Container, typename UnaryPredicate>\nContainer trim_right_by(UnaryPredicate p, const Container& xs)" }
    , { name = "trim_right", signature = "a, [a] -> [a]", documentation = "trim_right(4, [0,2,4,5,6,7,8,4,4]) == [0,2,4,5,6,7,8]", declaration = "template <typename Container,\n        typename T = typename Container::value_type>\nContainer trim_right(const T& x, const Container& xs)" }
    , { name = "trim_token_right", signature = "[a], [a] -> [a]", documentation = "trim_token_right([0,1,2], [7,5,9,0,1,2,0,1,2]) == [7,5,9]", declaration = "template <typename Container>\nContainer trim_token_right(const Container& token, const Container& xs)" }
    , { name = "trim_by", signature = "(a -> bool), [a] -> [a]", documentation = "trim_by(is_even, [0,2,4,5,6,7,8,6,4]) == [5,6,7]", declaration = "template <typename Container, typename UnaryPredicate>\nContainer trim_by(UnaryPredicate p, const Container& xs)" }
    , { name = "trim", signature = "a, [a] -> [a]", documentation = "trim(0, [0,2,4,5,6,7,8,0,0]) == [2,4,5,6,7,8]", declaration = "template <typename Container,\n        typename T = typename Container::value_type>\nContainer trim(const T& x, const Container& xs)" }
    , { name = "trim_token", signature = "[a], [a] -> [a]", documentation = "trim_token([0,1], [0,1,7,8,9,0,1]) == [7,8,9]", declaration = "template <typename Container>\nContainer trim_token(const Container& token, const Container& xs)" }
    , { name = "generate", signature = "(() -> a) -> [a]", documentation = "generate(f, 3) == [f(), f(), f()]", declaration = "template <typename ContainerOut, typename F>\nContainerOut generate(F f, std::size_t amount)" }
    , { name = "generate_by_idx", signature = "(Int -> a) -> [a]", documentation = "generate_by_idx(f, 3) == [f(0), f(1), f(2)]", declaration = "template <typename ContainerOut, typename F>\nContainerOut generate_by_idx(F f, std::size_t amount)" }
    , { name = "repeat", signature = "Int, [a] -> [a]", documentation = "repeat(3, [1, 2]) == [1, 2, 1, 2, 1, 2]", declaration = "template <typename Container>\nContainer repeat(size_t n, const Container& xs)" }
    , { name = "replicate", signature = "Int, a -> [a]", documentation = "replicate(3, 1) == [1, 1, 1]", declaration = "template <typename T,\n        typename ContainerOut = std::vector<T>>\nContainerOut replicate(size_t n, const T& x)" }
    , { name = "infixes", signature = "Int, [a] -> [[a]]", documentation = "infixes(3, [1,2,3,4,5,6]) == [[1,2,3], [2,3,4], [3,4,5], [4,5,6]]", declaration = "template <typename ContainerIn,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut infixes(std::size_t length, const ContainerIn& xs)" }
    , { name = "carthesian_product_with_where", signature = "(a, b -> c), (a, b -> bool), [a], [b] -> [c]", documentation = "carthesian_product_with_where(make_pair, always(true), \"ABC\", \"XY\")\n  == [(A,X),(A,Y),(B,X),(B,Y),(C,X),(C,Y)]\nsame as (in Haskell):\n  [ f x y | x <- xs, y <- ys, pred x y ]\nsame as (in pseudo SQL):\n  SELECT f(xs.x, ys.y)\n  FROM xs, ys\n  WHERE pred(xs.x, ys.y);", declaration = "template <typename F,\n    typename Pred,\n    typename Container1,\n    typename Container2,\n    typename X = typename Container1::value_type,\n    typename Y = typename Container2::value_type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename ContainerOut = std::vector<FOut>>\nContainerOut carthesian_product_with_where(F f, Pred pred,\n    const Container1& xs, const Container2& ys)" }
    , { name = "carthesian_product_with", signature = "(a, b -> c), [a], [b] -> [c]", documentation = "carthesian_product_with(make_pair, \"ABC\", \"XY\")\n== [(A,X),(A,Y),(B,X),(B,Y),(C,X),(C,Y)]", declaration = "template <typename F,\n    typename Container1,\n    typename Container2,\n    typename X = typename Container1::value_type,\n    typename Y = typename Container2::value_type,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename ContainerOut = std::vector<FOut>>\nContainerOut carthesian_product_with(F f,\n    const Container1& xs, const Container2& ys)" }
    , { name = "carthesian_product_where", signature = "(a, b -> bool), [a], [b] -> [(a, b)]", documentation = "carthesian_product_where(always(true), \"ABC\", \"XY\")\n== [(A,X),(A,Y),(B,X),(B,Y),(C,X),(C,Y)]", declaration = "template <typename Pred,\n    typename Container1,\n    typename Container2,\n    typename X = typename Container1::value_type,\n    typename Y = typename Container2::value_type,\n    typename Out = std::pair<X, Y>,\n    typename ContainerOut = std::vector<Out>>\nContainerOut carthesian_product_where(Pred pred,\n    const Container1& xs, const Container2& ys)" }
    , { name = "carthesian_product", signature = "[a], [b] -> [(a, b)]", documentation = "carthesian_product(\"ABC\", \"XY\") == [(A,X),(A,Y),(B,X),(B,Y),(C,X),(C,Y)]", declaration = "template <typename Container1,\n    typename Container2,\n    typename X = typename Container1::value_type,\n    typename Y = typename Container2::value_type,\n    typename Out = std::pair<X, Y>,\n    typename ContainerOut = std::vector<Out>>\nContainerOut carthesian_product(const Container1& xs, const Container2& ys)" }
    , { name = "carthesian_product_n", signature = "int, [a] -> [[a]]", documentation = "carthesian_product_n(2, \"ABCD\") == AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut carthesian_product_n(std::size_t power, const ContainerIn& xs_in)" }
    , { name = "permutations", signature = "int, [a] -> [[a]]", documentation = "permutations(2, \"ABCD\") == AB AC AD BA BC BD CA CB CD DA DB DC", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut permutations(std::size_t power, const ContainerIn& xs_in)" }
    , { name = "combinations", signature = "int, [a] -> [[a]]", documentation = "combinations(2, \"ABCD\") == AB AC AD BC BD CD", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut combinations(std::size_t power, const ContainerIn& xs_in)" }
    , { name = "combinations_with_replacement", signature = "int, [a] -> [[a]]", documentation = "combinations_with_replacement(2, \"ABCD\") == AA AB AC AD BB BC BD CC CD DD", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut combinations_with_replacement(std::size_t power,\n        const ContainerIn& xs_in)" }
    , { name = "power_set", signature = "[a] -> [[a]]", documentation = "power_set(\"xyz\") == [\"\", \"x\", \"y\", \"z\", \"xy\", \"xz\", \"yz\", \"xyz\"]", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut power_set(const ContainerIn& xs_in)" }
    , { name = "iterate", signature = "(a -> a -> a), int, a -> [a]", documentation = "iterate((*2), 5, 3) = [3, 6, 12, 24, 48]\n= [3, f(3), f(f(3)), f(f(f(3))), f(f(f(f(3))))]", declaration = "template <typename F,\n    typename T,\n    typename ContainerOut = std::vector<T>>\nContainerOut iterate(F f, std::size_t size, const T& x)" }
    , { name = "rotate_left", signature = "[a] -> [a]", documentation = "rotate_left(\"xyz\") == \"yzx\"", declaration = "template <typename Container>\nContainer rotate_left(const Container& xs)" }
    , { name = "rotate_right", signature = "[a] -> [a]", documentation = "rotate_right(\"xyz\") == \"zxy\"", declaration = "template <typename Container>\nContainer rotate_right(const Container& xs)" }
    , { name = "rotations_left", signature = "[a] -> [[a]]", documentation = "rotations_left(\"abcd\") == [\"abcd\", \"bcda\", \"cdab\", \"dabc\"]", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut rotations_left(const ContainerIn& xs_in)" }
    , { name = "rotations_right", signature = "[a] -> [[a]]", documentation = "rotations_right(\"abcd\") == [\"abcd\", \"dabc\", \"cdab\", \"bcda\"]", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut rotations_right(const ContainerIn& xs_in)" }
    , { name = "fill_left", signature = "a, int, [a] -> [a]", documentation = "fill_left(0, 6, [1,2,3,4]) == [0,0,1,2,3,4]", declaration = "template <typename Container,\n        typename T = typename Container::value_type>\nContainer fill_left(const T& x, std::size_t min_size, const Container& xs)" }
    , { name = "fill_right", signature = "a, int, [a] -> [a]", documentation = "fill_right(0, 6, [1,2,3,4]) == [1,2,3,4,0,0]", declaration = "template <typename Container,\n        typename T = typename Container::value_type>\nContainer fill_right(const T& x, std::size_t min_size, const Container& xs)" }
    , { name = "inits", signature = "[a] -> [[a]]", documentation = "inits([0,1,2,3]) == [[],[0],[0,1],[0,1,2],[0,1,2,3]]", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut inits(const ContainerIn& xs)" }
    , { name = "tails", signature = "[a] -> [[a]]", documentation = "tails([0,1,2,3]) == [[0,1,2,3],[1,2,3],[2,3],[3],[]]", declaration = "template <typename ContainerIn,\n    typename T = typename ContainerIn::value_type,\n    typename ContainerOut = std::vector<ContainerIn>>\nContainerOut tails(const ContainerIn& xs)" }
    , { name = "pairs_to_map", signature = "[a, b] -> map a b", documentation = "Converts a Container of pairs (key, value) into a dictionary.", declaration = "template <typename MapOut, typename ContainerIn>\nMapOut pairs_to_map(const ContainerIn& pairs)" }
    , { name = "pairs_to_map_grouped", signature = "[a, b] -> map a [b]", documentation = "pairs_to_map_grouped([(\"a\", 1), (\"a\", 2), (\"b\", 6), (\"a\", 4)])\n    -> [(\"a\", [1, 2, 4]), (\"b\", [6])]", declaration = "template <typename ContainerIn,\n    typename Key = typename ContainerIn::value_type::first_type,\n    typename SingleValue = typename ContainerIn::value_type::second_type,\n    typename MapOut = std::map<Key, std::vector<SingleValue>>>\nMapOut pairs_to_map_grouped(const ContainerIn& pairs)" }
    , { name = "map_to_pairs", signature = "map a b -> [(a, b)]", documentation = "Converts a dictionary into a Container of pairs (key, value).", declaration = "template <typename MapType,\n    typename MapPair = typename MapType::value_type,\n    typename Key = typename std::remove_const<typename MapPair::first_type>::type,\n    typename Val = typename std::remove_const<typename MapPair::second_type>::type,\n    typename OutPair = std::pair<Key, Val>,\n    typename ContainerOut = std::vector<OutPair>>\nContainerOut map_to_pairs(const MapType& dict)" }
    , { name = "transform_map_values", signature = "(b -> c), map a b -> map a c", documentation = "transform_map_values((*2), {(0, 2), (1, 3)}) == {(0, 4), (1, 6)}", declaration = "template <typename F, typename MapIn,\n    typename MapInPair = typename MapIn::value_type,\n    typename Key = typename std::remove_const<typename MapInPair::first_type>::type,\n    typename InVal = typename std::remove_const<typename MapInPair::second_type>::type,\n    typename OutVal = typename std::remove_reference<typename std::remove_const<typename utils::function_traits<F>::result_type>::type>::type,\n    typename MapOut = typename SameMapTypeNewTypes<MapIn, Key, OutVal>::type>\nMapOut transform_map_values(F f, const MapIn& map)" }
    , { name = "map_union_with", signature = "map a b, map a b -> map a b", documentation = "map_union_with((++), [(0,a), (1,b)], [(0,c), (2,d)]) == [(0,ac), (1,b), (2,d)]", declaration = "template <typename F, typename MapIn,\n    typename MapInPair = typename MapIn::value_type,\n    typename Key = typename std::remove_const<typename MapInPair::first_type>::type,\n    typename OutVal = typename std::remove_reference<typename std::remove_const<typename utils::function_traits<F>::result_type>::type>::type,\n    typename MapOut = typename SameMapTypeNewTypes<MapIn, Key, OutVal>::type>\nMapOut map_union_with(F f, const MapIn& dict1, const MapIn& dict2)" }
    , { name = "map_union", signature = "map a b, map a b -> map a b", documentation = "map_union([(0,a), (1,b)], [(0,c), (2,d)]) == [(0,a), (1,b), (2,d)]", declaration = "template <typename MapType,\n    typename MapInPair = typename MapType::value_type,\n    typename InVal = typename std::remove_const<typename MapInPair::second_type>::type>\nMapType map_union(const MapType& dict1, const MapType& dict2)" }
    , { name = "get_map_keys", signature = "map a b -> [a]", documentation = "Returns all keys used in a map.", declaration = "template <typename MapType,\n    typename ContainerOut =\n        std::vector<typename std::remove_const<typename MapType::key_type>::type>>\nContainerOut get_map_keys(const MapType& dict)" }
    , { name = "get_map_values", signature = "map a b -> [b]", documentation = "Returns all values present in a map.", declaration = "template <typename MapType,\n    typename ContainerOut =\n        std::vector<typename std::remove_const<typename MapType::mapped_type>::type>>\nContainerOut get_map_values(const MapType& dict)" }
    , { name = "swap_keys_and_values", signature = "map a b -> map b a", documentation = "Swaps keys and Values of a dict:\nswap_keys_and_values({(1, \"a\"), (2, \"b\")}) == {(\"a\", 1), (\"b\", 2)}", declaration = "template <typename MapIn,\n    typename MapInPair = typename MapIn::value_type,\n    typename InKey = typename MapInPair::first_type,\n    typename InVal = typename MapInPair::second_type,\n    typename OutKey = InVal,\n    typename OutVal = typename std::remove_const<InKey>::type,\n    typename MapOut = typename SameMapTypeNewTypes<MapIn, OutKey, OutVal>::type>\nMapOut swap_keys_and_values(const MapIn& dict)" }
    , { name = "create_map", signature = "[a], [b] -> map a b", documentation = "create_map([1,2,3], [\"one\", \"two\"]) == { {1,\"one\"}, {2,\"two\"} }", declaration = "template <typename ContainerIn1, typename ContainerIn2,\n    typename Key = typename std::remove_const<typename ContainerIn1::value_type>::type,\n    typename Val = typename std::remove_const<typename ContainerIn2::value_type>::type,\n    typename MapOut = std::map<Key, Val>>\nMapOut create_map(const ContainerIn1& keys, const ContainerIn2& values)" }
    , { name = "create_unordered_map", signature = "[a], [b] -> map a b", documentation = "create_unordered_map([1,2,3], [\"one\", \"two\"]) == { {1,\"one\"}, {2,\"two\"} }", declaration = "template <typename ContainerIn1, typename ContainerIn2,\n    typename Key = typename std::remove_const<typename ContainerIn1::value_type>::type,\n    typename Val = typename std::remove_const<typename ContainerIn2::value_type>::type,\n    typename MapOut = std::unordered_map<Key, Val >>\nMapOut create_unordered_map(\n    const ContainerIn1& keys,\n    const ContainerIn2& values)" }
    , { name = "get_from_map", signature = "map a b, a -> maybe b", documentation = "Returns just the value of a key if key is present.\nOtherwise returns nothing.", declaration = "template <typename MapType,\n    typename Key = typename MapType::key_type,\n    typename Val = typename MapType::mapped_type>\nmaybe<Val> get_from_map(const MapType& map, const Key& key)" }
    , { name = "get_from_map_with_def", signature = "map a b, b, a -> b", documentation = "Returns the value of a key if key is present.\nOtherwise returns the provided default.", declaration = "template <typename MapType,\n    typename Key = typename MapType::key_type,\n    typename Val = typename MapType::mapped_type>\nVal get_from_map_with_def(const MapType& map, const Val& defVal,\n    const Key& key)" }
    , { name = "map_contains", signature = "map a b, a -> bool", documentation = "Checks if a map contains a key.", declaration = "template <typename MapType, typename Key = typename MapType::key_type>\nbool map_contains(const MapType& map, const Key& key)" }
    , { name = "is_just", signature = "maybe a -> bool", documentation = "Is not nothing?", declaration = "template <typename T>\nbool is_just(const maybe<T>& maybe)" }
    , { name = "is_nothing", signature = "maybe a -> bool", documentation = "Has no value?", declaration = "template <typename T>\nbool is_nothing(const maybe<T>& maybe)" }
    , { name = "unsafe_get_just", signature = "maybe a -> a", documentation = "Crashes if maybe is nothing!", declaration = "template <typename T>\nT unsafe_get_just(const maybe<T>& maybe)" }
    , { name = "just_with_default", signature = "a, maybe a -> a", documentation = "Get the value from a maybe or the default in case it is nothing.", declaration = "template <typename T>\nT just_with_default(const T& defaultValue, const maybe<T>& maybe)" }
    , { name = "throw_on_nothing", signature = "e, maybe a -> a", documentation = "Throw exception if nothing. Return value if just.", declaration = "template <typename E, typename T>\nT throw_on_nothing(const E& e, const maybe<T>& maybe)" }
    , { name = "just", signature = "a -> maybe a", documentation = "Wrap a value in a Maybe as a Just.", declaration = "template <typename T>\nmaybe<T> just(const T& val)" }
    , { name = "just", signature = "() -> maybe a", documentation = "Construct a nothing of a certain Maybe type.", declaration = "template <typename T>\nmaybe<T> nothing()" }
    , { name = "lift_maybe", signature = "(a -> b) -> (maybe a -> maybe b)", documentation = "Lifts a function into the maybe functor.\nA function that for example was able to convert and int into a string,\nnow can convert a Maybe<int> into a Maybe<string>.\nA nothings stays a nothing, regardless of the conversion.", declaration = "template <typename F,\n    typename A = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::template arg<0>::type>::type>::type,\n    typename B = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::result_type>::type>::type>\nstd::function<maybe<B>(const maybe<A>&)> lift_maybe(F f)" }
    , { name = "and_then_maybe", signature = "(a -> maybe b), (b -> maybe c) -> (a -> maybe c)", documentation = "Monadic bind.\nComposes two functions taking a value and returning Maybe.\nIf the first function returns a just, the value from the just\nis extracted and shoved into the second function.\nIf the first functions returns a nothing, it stays a nothing.", declaration = "template <typename F, typename G,\n    typename FIn = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::template arg<0>::type>::type>::type,\n    typename FOut = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::result_type>::type>::type,\n    typename GIn = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<G>::template arg<0>::type>::type>::type,\n    typename GOut = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<G>::result_type>::type>::type,\n    typename T = typename GOut::type>\nstd::function<maybe<T>(const FIn&)> and_then_maybe(F f, G g)" }
    , { name = "and_then_maybe", signature = "(a -> maybe b), (b -> maybe c), (c -> maybe d) -> (maybe a -> maybe d)", documentation = "Monadic bind.", declaration = "template <typename F, typename G, typename H,\n    typename FIn = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::template arg<0>::type>::type>::type,\n    typename HOut = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<H>::result_type>::type>::type,\n    typename T = typename HOut::type>\nstd::function<maybe<T>(const FIn&)> and_then_maybe(F f, G g, H h)" }
    , { name = "and_then_maybe", signature = "(a -> maybe b), (b -> maybe c), (c -> maybe d), (d -> maybe e) -> (maybe a -> maybe e)", documentation = "Monadic bind.", declaration = "template <typename F, typename G, typename H, typename I,\n    typename FIn = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::template arg<0>::type>::type>::type,\n    typename IOut = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<I>::result_type>::type>::type,\n    typename T = typename IOut::type>\nstd::function<maybe<T>(const FIn&)> and_then_maybe(F f, G g, H h, I i)" }
    , { name = "is_in_range", signature = "a, a -> (a -> bool)", documentation = "Checks if x is in [low, high), i.e. left-closed and right-open.", declaration = "template <typename T>\nstd::function<bool(const T&)>\n        is_in_range(const T& low, const T& high)" }
    , { name = "clamp", signature = "a, a -> (a -> a)", documentation = "Puts value into [low, high], i.e. left-closed and right-closed.", declaration = "template <typename T>\nstd::function<T(const T&)>\n        clamp(const T& low, const T& high)" }
    , { name = "is_negative", signature = "a -> bool", documentation = "Checks if x < 0.", declaration = "template <typename X>\nbool is_negative(X x)" }
    , { name = "is_positive", signature = "a -> bool", documentation = "Checks if x is not negative.", declaration = "template <typename X>\nbool is_positive(X x)" }
    , { name = "abs", signature = "a -> a", documentation = "Returns the absolute (always positive) value of x.", declaration = "template <typename X>\nX abs(X x)" }
    , { name = "sign", signature = "a -> int", documentation = "Returns -1 for negative values, 1 otherwise.", declaration = "template <typename X>\nint sign(X x)" }
    , { name = "round", signature = "a -> b", documentation = "Converts a value to the nearest integer.", declaration = "template <typename Out, typename X>\nOut round(X x)" }
    , { name = "floor", signature = "a -> b", documentation = "Converts a value to the nearest smaller integer.", declaration = "template <typename Out, typename X>\nOut floor(X x)" }
    , { name = "ceil", signature = "a -> b", documentation = "Converts a value to the nearest greater integer.", declaration = "template <typename Out, typename X>\nOut ceil(X x)" }
    , { name = "int_power", signature = "int, int -> int", documentation = "integer power", declaration = "template <typename X>\nX int_power(X base, X exp)" }
    , { name = "min_2_on", signature = "(a -> b) -> (a, a -> bool)", documentation = "minimum of two values after transformation", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<const FIn&(const FIn& x, const FIn& y)>\n        min_2_on(F f)" }
    , { name = "max_2_on", signature = "(a -> b) -> (a, a -> bool)", documentation = "maximum of two values after transformation", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<const FIn&(const FIn& x, const FIn& y)>\n        max_2_on(F f)" }
    , { name = "min_3_on", signature = "(a -> b) -> (a, a, a -> bool)", documentation = "minimum of three values after transformation", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<const FIn&(const FIn& x, const FIn& y, const FIn& z)>\n        min_3_on(F f)" }
    , { name = "max_3_on", signature = "(a -> b) -> (a, a, a -> bool)", documentation = "maximum of three values after transformation", declaration = "template <typename F,\n    typename FIn = typename utils::function_traits<F>::template arg<0>::type>\nstd::function<const FIn&(const FIn& x, const FIn& y, const FIn& z)>\n        max_3_on(F f)" }
    , { name = "min_2", signature = "a, a -> a", documentation = "Minimum of two values.", declaration = "template <typename X>\nconst X& min_2(const X& a, const X& b)" }
    , { name = "min_3", signature = "a, a, a -> a", documentation = "Minimum of three values.", declaration = "template <typename X>\nconst X& min_3(const X& a, const X& b, const X& c)" }
    , { name = "min_4", signature = "a, a, a, a -> a", documentation = "Minimum of four values.", declaration = "template <typename X>\nconst X& min_4(const X& a, const X& b, const X& c, const X& d)" }
    , { name = "min_5", signature = "a, a, a, a, a -> a", documentation = "Minimum of five values.", declaration = "template <typename X>\nconst X& min_5(const X& a, const X& b, const X& c, const X& d, const X& e)" }
    , { name = "max_2", signature = "a, a -> a", documentation = "Maximum of two values.", declaration = "template <typename X>\nconst X& max_2(const X& a, const X& b)" }
    , { name = "max_3", signature = "a, a, a -> a", documentation = "Maximum of three values.", declaration = "template <typename X>\nconst X& max_3(const X& a, const X& b, const X& c)" }
    , { name = "max_4", signature = "a, a, a, a -> a", documentation = "Maximum of four values.", declaration = "template <typename X>\nconst X& max_4(const X& a, const X& b, const X& c, const X& d)" }
    , { name = "max_5", signature = "a, a, a, a, a -> a", documentation = "Maximum of five values.", declaration = "template <typename X>\nconst X& max_5(const X& a, const X& b, const X& c, const X& d, const X& e)" }
    , { name = "zip_with", signature = "(a, b -> c), [a], [b] -> [c]", documentation = "zip_with((+), [1, 2, 3], [5, 6]) == [6, 8]", declaration = "template <typename ContainerIn1, typename ContainerIn2, typename F,\n    typename X = typename ContainerIn1::value_type,\n    typename Y = typename ContainerIn2::value_type,\n    typename TOut = typename utils::function_traits<F>::result_type,\n    typename ContainerOut = typename std::vector<TOut>>\nContainerOut zip_with(const F& f,\n        const ContainerIn1& xs, const ContainerIn2& ys)" }
    , { name = "zip", signature = "[a], [b] -> [(a, b)]", documentation = "zip([1, 2, 3], [5, 6]) == [(1, 5), (2, 6)]", declaration = "template <typename ContainerIn1, typename ContainerIn2,\n    typename X = typename ContainerIn1::value_type,\n    typename Y = typename ContainerIn2::value_type,\n    typename TOut = std::pair<X, Y>,\n    typename ContainerOut = typename std::vector<TOut>>\nContainerOut zip(const ContainerIn1& xs, const ContainerIn2& ys)" }
    , { name = "unzip", signature = "[(a, b)] -> ([a], [b])", documentation = "unzip([(1, 5), (2, 6)]) == ([1, 2], [5, 6])", declaration = "template <typename ContainerIn,\n    typename TIn = typename ContainerIn::value_type,\n    typename X = typename TIn::first_type,\n    typename Y = typename TIn::second_type,\n    typename ContainerOutX = typename same_cont_new_t<ContainerIn, X>::type,\n    typename ContainerOutY = typename same_cont_new_t<ContainerIn, Y>::type>\nstd::pair<ContainerOutX, ContainerOutY> unzip(const ContainerIn& pairs)" }
    , { name = "fst", signature = "(a, b) -> a", documentation = "fst((0, 1)) == 0", declaration = "template <typename X, typename Y>\nX fst(const std::pair<X, Y>& pair)" }
    , { name = "snd", signature = "(a, b) -> b", documentation = "snd((0, 1)) == 1", declaration = "template <typename X, typename Y>\nY snd(const std::pair<X, Y>& pair)" }
    , { name = "transform_fst", signature = "(a -> c), (a, b) -> (c, b)", documentation = "transform_fst(square, (4, 5)) == (16, 5)", declaration = "template <typename X, typename Y, typename F,\n    typename ResultFirst = typename utils::function_traits<F>::result_type>\nstd::pair<ResultFirst, Y> transform_fst(F f, const std::pair<X, Y>& pair)" }
    , { name = "transform_snd", signature = "(b -> c), (a, b) -> (a, c)", documentation = "transform_snd(square, (4, 5)) == (4, 25)", declaration = "template <typename X, typename Y, typename F,\n    typename ResultSecond = typename utils::function_traits<F>::result_type>\nstd::pair<X, ResultSecond> transform_snd(F f, const std::pair<X, Y>& pair)" }
    , { name = "transform_pair", signature = "(a -> c), (b -> d), (a, b) -> (c, d)", documentation = "transform_pair(square, square, (4, 5)) == (16, 25)", declaration = "template <typename X, typename Y, typename F, typename G,\n    typename ResultFirst = typename utils::function_traits<F>::result_type,\n    typename ResultSecond = typename utils::function_traits<G>::result_type>\nstd::pair<ResultFirst, ResultSecond> transform_pair(F f, G g, const std::pair<X, Y>& pair)" }
    , { name = "swap_pair_elems", signature = "(a, b) -> (b, a)", documentation = "swap_pair_elems((3,4)) == (4,3)", declaration = "template <typename X, typename Y>\nstd::pair<Y, X> swap_pair_elems(const std::pair<X, Y>& pair)" }
    , { name = "overlapping_pairs", signature = "[a] -> [(a, a)]", documentation = "overlapping_pairs([0,1,2,3]) == [(0,1),(1,2),(2,3)]", declaration = "template <typename ContainerOut, typename Container,\n    typename T = typename Container::value_type,\n    typename Pair = typename std::pair<T, T>>\nContainerOut overlapping_pairs(const Container& xs)" }
    , { name = "replace_if", signature = "(a -> bool), a, [a] -> [a]", documentation = "replace_if(is_even, 0, [1, 3, 4, 6, 7]) == [1, 3, 0, 0, 7]", declaration = "template <typename UnaryPredicate, typename Container>\nContainer replace_if(UnaryPredicate p,\n        const typename Container::value_type& dest, const Container& xs)" }
    , { name = "replace_elems", signature = "a, a, [a] -> [a]", documentation = "replace_elems(4, 0, [1, 3, 4, 4, 7]) == [1, 3, 0, 0, 7]", declaration = "template <typename Container,\n        typename T = typename Container::value_type>\nContainer replace_elems(const T& source, const T& dest, const Container& xs)" }
    , { name = "replace_tokens", signature = "[a], [a], [a] -> [a]", documentation = "replace_tokens(\"haha\", \"hihi\", \"oh, hahaha!\") == \"oh, hihiha!\"", declaration = "template <typename Container>\nContainer replace_tokens\n        (const Container& source, const Container& dest, const Container& xs)" }
    , { name = "is_ok", signature = "result a b -> bool", documentation = "Is not error?", declaration = "template <typename Ok, typename Error>\nbool is_ok(const result<Ok, Error>& result)" }
    , { name = "is_error", signature = "result a b -> bool", documentation = "Has no value?", declaration = "template <typename Ok, typename Error>\nbool is_error(const result<Ok, Error>& result)" }
    , { name = "unsafe_get_ok", signature = "result a b -> a", documentation = "Crashes if result is error!", declaration = "template <typename Ok, typename Error>\nOk unsafe_get_ok(const result<Ok, Error>& result)" }
    , { name = "unsafe_get_ok", signature = "result a b -> b", documentation = "Crashes if result is ok!", declaration = "template <typename Ok, typename Error>\nError unsafe_get_error(const result<Ok, Error>& result)" }
    , { name = "ok_with_default", signature = "a, result a b -> a", documentation = "Get the value from a result or the default in case it is error.", declaration = "template <typename Ok, typename Error>\nOk ok_with_default(const Ok& defaultValue, const result<Ok, Error>& result)" }
    , { name = "ok", signature = "a -> result a b", documentation = "Wrap a value in a result as a Ok.", declaration = "template <typename Ok, typename Error>\nresult<Ok, Error> ok(const Ok& val)" }
    , { name = "error", signature = "b -> result a b", documentation = "Construct an error of a certain result type.", declaration = "template <typename Ok, typename Error>\nresult<Ok, Error> error(const Error& error)" }
    , { name = "to_maybe", signature = "result a b -> maybe a", documentation = "Convert ok to just, error to nothing.", declaration = "template <typename Ok, typename Error>\nmaybe<Ok> to_maybe(const result<Ok, Error>& result)" }
    , { name = "from_maybe", signature = "maybe a, b -> result a b", documentation = "Convert just to ok, nothing to error.", declaration = "template <typename Ok, typename Error>\nresult<Ok, Error> from_maybe(const maybe<Ok>& maybe, const Error& err)" }
    , { name = "throw_on_error", signature = "e, result a b -> a", documentation = "Throws the given exception in case of error.\nReturn ok value if ok.", declaration = "template <typename E, typename Ok, typename Error>\nOk throw_on_error(const E& e, const result<Ok, Error>& result)" }
    , { name = "throw_type_on_error", signature = "result a b -> a", documentation = "Throws the given exception type constructed with error value if error.\nReturn ok value if ok.", declaration = "template <typename E, typename Ok, typename Error>\nOk throw_type_on_error(const result<Ok, Error>& result)" }
    , { name = "lift_result", signature = "(a -> b) -> (result a c -> result b c)", documentation = "Lifts a function into the result functor.\nA function that for example was able to convert and int into a string,\nnow can convert a result<int> into a result<string>.\nAn errors stays the same error, regardless of the conversion.", declaration = "template <typename Error,\n    typename F,\n    typename A = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::template arg<0>::type>::type>::type,\n    typename B = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::result_type>::type>::type>\nstd::function<result<B, Error>(const result<A, Error>&)> lift_result(F f)" }
    , { name = "and_then_result", signature = "(a -> result b c), (b -> result d c) -> (a -> result d c)", documentation = "Monadic bind.\nComposes two functions taking a value and returning result.\nIf the first function returns a ok, the value from the ok\nis extracted and shoved into the second function.\nIf the first functions returns an error, the error is forwarded.", declaration = "template <typename F, typename G,\n    typename FIn = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::template arg<0>::type>::type>::type,\n    typename FOut = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::result_type>::type>::type,\n    typename GIn = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<G>::template arg<0>::type>::type>::type,\n    typename GOut = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<G>::result_type>::type>::type,\n    typename Ok = typename GOut::ok_t,\n    typename Error = typename GOut::error_t>\nstd::function<result<Ok, Error>(const FIn&)> and_then_result(F f, G g)" }
    , { name = "and_then_result", signature = "(a -> result b c), (b -> result d c), (d -> result e c) -> (a -> result e c)", documentation = "Monadic bind.", declaration = "template <typename F, typename G, typename H,\n    typename FIn = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::template arg<0>::type>::type>::type,\n    typename HOut = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<H>::result_type>::type>::type,\n    typename Ok = typename HOut::ok_t,\n    typename Error = typename HOut::error_t>\nstd::function<result<Ok, Error>(const FIn&)> and_then_result(F f, G g, H h)" }
    , { name = "and_then_result", signature = "(a -> result b c), (b -> result d c), (d -> result e c), (e -> result f c) -> (a -> result f c)", documentation = "Monadic bind.", declaration = "template <typename F, typename G, typename H, typename I,\n    typename FIn = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<F>::template arg<0>::type>::type>::type,\n    typename IOut = typename std::remove_const<typename std::remove_reference<typename utils::function_traits<I>::result_type>::type>::type,\n    typename Ok = typename IOut::ok_t,\n    typename Error = typename IOut::error_t>\nstd::function<result<Ok, Error>(const FIn&)> and_then_result(F f, G g, H h, I i)" }
    , { name = "find_first_by", signature = "(a -> bool), [a] -> maybe a", documentation = "find_first_by(is_even, [1, 3, 4, 6, 9]) == Just(4)\nfind_first_by(is_even, [1, 3, 5, 7, 9]) == Nothing", declaration = "template <typename Container, typename UnaryPredicate,\n    typename T = typename Container::value_type>\nmaybe<T> find_first_by(UnaryPredicate pred, const Container& xs)" }
    , { name = "find_last_by", signature = "(a -> bool), [a] -> maybe a", documentation = "find_last_by(is_even, [1, 3, 4, 6, 9]) == Just(6)\nfind_last_by(is_even, [1, 3, 5, 7, 9]) == Nothing", declaration = "template <typename Container, typename UnaryPredicate,\n    typename T = typename Container::value_type>\nmaybe<T> find_last_by(UnaryPredicate pred, const Container& xs)" }
    , { name = "find_first_idx_by", signature = "(a -> bool), [a] -> maybe int", documentation = "find_first_idx_by(is_even, [1, 3, 4, 6, 9]) == Just(2)\nfind_first_idx_by(is_even, [1, 3, 5, 7, 9]) == Nothing", declaration = "template <typename Container, typename UnaryPredicate>\nmaybe<std::size_t> find_first_idx_by\n        (UnaryPredicate pred, const Container& xs)" }
    , { name = "find_last_idx_by", signature = "(a -> bool), [a] -> maybe int", documentation = "find_last_idx_by(is_even, [1, 3, 4, 6, 9]) == Just(3)\nfind_last_idx_by(is_even, [1, 3, 5, 7, 9]) == Nothing", declaration = "template <typename Container, typename UnaryPredicate>\nmaybe<std::size_t> find_last_idx_by\n        (UnaryPredicate pred, const Container& xs)" }
    , { name = "find_first_idx", signature = "a, [a] -> maybe int", documentation = "find_first_idx(4, [1, 3, 4, 4, 9]) == Just(2)\nfind_first_idx(4, [1, 3, 5, 7, 9]) == Nothing", declaration = "template <typename Container>\nmaybe<std::size_t> find_first_idx\n        (const typename Container::value_type& x, const Container& xs)" }
    , { name = "find_last_idx", signature = "a, [a] -> maybe int", documentation = "find_last_idx(4, [1, 3, 4, 4, 9]) == Just(3)\nfind_last_idx(4, [1, 3, 5, 7, 9]) == Nothing", declaration = "template <typename Container>\nmaybe<std::size_t> find_last_idx\n        (const typename Container::value_type& x, const Container& xs)" }
    , { name = "find_all_idxs_by", signature = "(a -> bool), [a] -> [int]", documentation = "find_all_idxs_by(is_even, [1, 3, 4, 6, 9]) == [2, 3]", declaration = "template <typename ContainerOut = std::vector<std::size_t>,\n        typename UnaryPredicate, typename Container>\nContainerOut find_all_idxs_by(UnaryPredicate p, const Container& xs)" }
    , { name = "find_all_idxs_of", signature = "a, [a] -> [int]", documentation = "find_all_idxs_of(4, [1, 3, 4, 4, 9]) == [2, 3]", declaration = "template <typename ContainerOut = std::vector<std::size_t>,\n        typename Container,\n        typename T = typename Container::value_type>\nContainerOut find_all_idxs_of\n        (const T& x, const Container& xs)" }
    , { name = "find_all_instances_of_token", signature = "[a], [a] -> [int]", documentation = "find_all_instances_of_token(\"haha\", \"oh, hahaha!\") == [4, 6]", declaration = "template <typename ContainerOut = std::vector<std::size_t>, typename Container>\nContainerOut find_all_instances_of_token(const Container& token,\n        const Container& xs)" }
    , { name = "find_all_instances_of_token_non_overlapping", signature = "[a], [a] -> [int]", documentation = "find_all_instances_of_token_non_overlapping(\"haha\", \"oh, hahaha!\") == [4]", declaration = "template <typename ContainerOut = std::vector<std::size_t>, typename Container>\nContainerOut find_all_instances_of_token_non_overlapping\n        (const Container& token, const Container& xs)" }
    , { name = "find_first_instance_of_token", signature = "[a], [a] -> maybe int", documentation = "find_first_instance_of_token(\"haha\", \"oh, hahaha!\") == just 4", declaration = "template <typename Container>\nmaybe<std::size_t> find_first_instance_of_token\n        (const Container& token, const Container& xs)" }
    , { name = "includes", signature = "set a, set a -> bool", documentation = "Checks if every element of the second set is also present in the first set.", declaration = "template <typename SetType>\nbool set_includes(const SetType& set1, const SetType& set2)" }
    , { name = "merge", signature = "set a, set a -> set a", documentation = "Returns the union of two given sets.", declaration = "template <typename SetType>\nSetType set_merge(const SetType& set1, const SetType& set2)" }
    , { name = "set_intersection", signature = "set a, set a -> set a", documentation = "Returns the intersection of both sets.", declaration = "template <typename SetType>\nSetType set_intersection(const SetType& set1, const SetType& set2)" }
    , { name = "set_difference", signature = "set a, set a -> set a", documentation = "Returns the elements in set1 that are not present in set2.", declaration = "template <typename SetType>\nSetType set_difference(const SetType& set1, const SetType& set2)" }
    , { name = "set_symmetric_difference", signature = "set a, set a -> set a", documentation = "Returns the symmetric difference of both sets.", declaration = "template <typename SetType>\nSetType set_symmetric_difference(const SetType& set1, const SetType& set2)" }
    , { name = "show", signature = "a -> string", documentation = "42 -> \"42\"", declaration = "template <typename T>\nstd::string show(const T& x)" }
    , { name = "show", signature = "string -> string", documentation = "string identity\n\"foo\" -> \"foo\"", declaration = "inline\nstd::string show(const std::string& str)" }
    , { name = "show", signature = "(a, b) -> string", documentation = "{1, \"one\"} -> \"(1, one)\"", declaration = "template <typename X, typename Y>\nstd::string show(const std::pair<X, Y>& p)" }
    , { name = "show_cont_with_frame_and_newlines", signature = "string, string, string, [a], int -> string", documentation = "show_cont_with_frame_and_newlines (\",\", \"(\", \")\", [1, 2, 3, 4, 5], 2)\n== \"(1,2)\n     3,4)\n     5)\"", declaration = "template <typename Container>\nstd::string show_cont_with_frame_and_newlines(\n    const std::string& separator,\n    const std::string& prefix, const std::string& suffix,\n    const Container& xs,\n    std::size_t new_line_every_nth_elem )" }
    , { name = "show_cont_with_frame", signature = "string, string, string, [a] -> string", documentation = "show_cont_with_frame (\" => \", \"{\", \"}\", [1, 2, 3]) == \"{1 => 2 => 3}\"", declaration = "template <typename Container>\nstd::string show_cont_with_frame(\n    const std::string& separator,\n    const std::string& prefix, const std::string& suffix,\n    const Container& xs)" }
    , { name = "show_cont_with", signature = "string, [a] -> string", documentation = "show_cont_with( \" - \", [1, 2, 3]) == \"[1 - 2 - 3]\"", declaration = "template <typename Container>\nstd::string show_cont_with(const std::string& separator, const Container& xs)" }
    , { name = "show_cont", signature = "[a] -> string", documentation = "show_cont [1, 2, 3] -> \"[1, 2, 3]\"", declaration = "template <typename Container>\nstd::string show_cont(const Container& xs)" }
    , { name = "show_maybe", signature = "maybe a -> string", documentation = "show_maybe(Just 42) -> \"Just 42\"", declaration = "template <typename T>\nstd::string show_maybe(const maybe<T>& maybe)" }
    , { name = "show_result", signature = "result a b -> string", documentation = "show_result(Ok 42) -> \"Ok 42\"\nshow_result(Error \"fail\") -> \"Error fail\"", declaration = "template <typename Ok, typename Error>\nstd::string show_result(const result<Ok, Error>& result)" }
    , { name = "sleep_for_n_seconds", signature = "int -> io ()", documentation = "Returns a function that suspends the calling thread for n seconds.", declaration = "inline\nstd::function<void()> sleep_for_n_seconds(std::size_t seconds)" }
    , { name = "sleep_for_n_milliseconds", signature = "int -> io ()", documentation = "Returns a function that suspends the calling thread for n milliseconds.", declaration = "inline\nstd::function<void()> sleep_for_n_milliseconds(std::size_t milliseconds)" }
    , { name = "sleep_for_n_microseconds", signature = "int -> io ()", documentation = "Returns a function that suspends the calling thread for n microseconds.", declaration = "inline\nstd::function<void()> sleep_for_n_microseconds(std::size_t microseconds)" }
    , { name = "execute_serially", signature = "[io ()] -> io ()", documentation = "Returns a function that executes the given side effects one after another.", declaration = "template <typename Container,\n        typename Effect = typename Container::value_type,\n        typename Result = typename utils::function_traits<Effect>::result_type>\nstd::function<std::vector<Result>()> execute_serially(const Container& effs)" }
    , { name = "execute_serially_until_success", signature = "[io bool] -> io bool", documentation = "Returns a function that executes the given side effects one after another\nuntil one of it returns true.", declaration = "template <typename Container,\n        typename Effect = typename Container::value_type,\n        typename Result = typename utils::function_traits<Effect>::result_type>\nstd::function<bool()> execute_serially_until_success(const Container& effs)" }
    , { name = "execute_and_return_fixed_value", signature = "a, [io b] -> io a", documentation = "Returns a function that executes the given side effect\nand returns a fixed value.", declaration = "template <typename Result, typename Effect>\nstd::function<Result()> execute_and_return_fixed_value(\n        Result result,\n        Effect eff)" }
    , { name = "execute_max_n_times_until_success", signature = "int, io (), int -> io bool", documentation = "Returns a function that executes a side effect until it succeds\nwith a maximum number of attempts and an optinal pause in milliseconds.", declaration = "template <typename Effect,\n        typename Result = typename utils::function_traits<Effect>::result_type>\nstd::function<bool()> execute_max_n_times_until_success(\n        std::size_t n,\n        const Effect& eff,\n        std::size_t pause_in_milliseconds = 0)" }
    , { name = "execute_serially_until_failure", signature = "[io bool] -> io bool", documentation = "Returns a function that executes the given side effects one after another\nuntil one of them returns false.", declaration = "template <typename Container,\n        typename Effect = typename Container::value_type,\n        typename Result = typename utils::function_traits<Effect>::result_type>\nstd::function<bool()> execute_serially_until_failure(const Container& effs)" }
    , { name = "execute_parallelly", signature = "[io a] -> io [a]", documentation = "Returns a function that executes the given side effects in parallel\nand returns the collected results.\nCan be used for something like MapReduce.", declaration = "template <typename Container,\n        typename Effect = typename Container::value_type,\n        typename Result = typename utils::function_traits<Effect>::result_type>\nstd::function<std::vector<Result>()> execute_parallelly(const Container& effs)" }
    , { name = "execute_fire_and_forget", signature = "io a -> io a", documentation = "Returns a function that executes the given side effect in a new thread\nand return immediately.", declaration = "template <typename Effect>\nstd::function<void()> execute_fire_and_forget(Effect eff)" }
    , { name = "read_text_file", signature = "string -> io string", documentation = "Returns a function that reads the content of a text file.", declaration = "inline\nstd::function<std::string()> read_text_file(const std::string& filename)" }
    , { name = "read_text_file_lines", signature = "string -> io [string]", documentation = "Returns a function that reads the content of a text file\nand returns it line by line.", declaration = "inline\nstd::function<std::vector<std::string>()> read_text_file_lines(\n        const std::string& filename)" }
    , { name = "write_text_file", signature = "string, string -> io bool", documentation = "Returns a function that writes content into a text file,\nreplacing it if it already exists.", declaration = "inline\nstd::function<bool()> write_text_file(const std::string& filename,\n        const std::string& content)" }
    , { name = "write_text_file_lines", signature = "string, [string], bool -> io bool", documentation = "Returns a function that writes lines into a text file,\nreplacing it if it already exists.", declaration = "inline\nstd::function<bool()> write_text_file_lines(const std::string& filename,\n        const std::vector<std::string>& lines, bool trailing_newline = true)" }
    , { name = "group_by", signature = "(a, a -> bool), [a] -> [[a]]", documentation = "group_by((==), [1,2,2,2,3,2,2,4,5,5]) == [[1],[2,2,2],[3],[2,2],[4],[5,5]]\nContainerOut is not deduced to\nSameContNewType(ContainerIn, ContainerIn)\nhere, since ContainerIn could be a std::string.", declaration = "template <typename BinaryPredicate, typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut group_by(BinaryPredicate p, const ContainerIn& xs)" }
    , { name = "group_on", signature = "(a -> b), [a] -> [[a]]", documentation = "group_on((mod 10), [12,22,34]) == [[12,22],[34]]", declaration = "template <typename F, typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut group_on(F f, const ContainerIn& xs)" }
    , { name = "group", signature = "[a] -> [[a]]", documentation = "group([1,2,2,2,3,2,2,4,5,5]) == [[1],[2,2,2],[3],[2,2],[4],[5,5]]", declaration = "template <typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut group(const ContainerIn& xs)" }
    , { name = "group_globally_by", signature = "(a, a -> bool), [a] -> [[a]]", documentation = "group_globally_by((==), [1,2,2,2,3,2,2,4,5,5])\n== [[1],[2,2,2,2,2],[3],[4],[5,5]]\nO(n^2)", declaration = "template <typename BinaryPredicate, typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut group_globally_by(BinaryPredicate p, const ContainerIn& xs)" }
    , { name = "group_globally_on", signature = "(a -> b), [a] -> [[a]]", documentation = "group_globally_on((mod 10), [12,34,22]) == [[12,34],[22]]\nO(n^2)", declaration = "template <typename F, typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut group_globally_on(F f, const ContainerIn& xs)" }
    , { name = "group_globally", signature = "[a] -> [[a]]", documentation = "group_globally([1,2,2,2,3,2,2,4,5,5]) == [[1],[2,2,2,2,2],[3],[4],[5,5]]\nO(n^2)", declaration = "template <typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut group_globally(const ContainerIn& xs)" }
    , { name = "split_by", signature = "(a -> bool), bool, [a] -> [[a]]", documentation = "split_by(is_even, true, [1,3,2,2,5,5,3,6,7,9]) == [[1,3],[],[5,5,3],[7,9]]\nalso known as split_when", declaration = "template <typename UnaryPredicate, typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut split_by\n        (UnaryPredicate pred, bool allowEmpty, const ContainerIn& xs)" }
    , { name = "split_by_keep_separators", signature = "(a -> bool), [a] -> [[a]]", documentation = "split_by_keep_separators(is_even, true, [1,3,2,2,5,5,3,6,7,9]) == [[1,3],[2],[2,5,5,3],[6,7,9]]", declaration = "template <typename UnaryPredicate, typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut split_by_keep_separators\n        (UnaryPredicate pred, const ContainerIn& xs)" }
    , { name = "split", signature = "a, [a] -> [[a]]", documentation = "split(0, [1,3,2,0,0,6,0,7,5]) == [[1,3,2],[],[6],[7,5]]", declaration = "template <typename ContainerIn,\n        typename T = typename ContainerIn::value_type,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut split(const T& x, bool allowEmpty, const ContainerIn& xs)" }
    , { name = "split_at_idx", signature = "int, [a] -> ([a], [a])", documentation = "split_at_idx(2, [0,1,2,3,4]) == ([0,1],[2,3,4])", declaration = "template <typename Container>\nstd::pair<Container, Container> split_at_idx\n        (std::size_t idx, const Container& xs)" }
    , { name = "partition", signature = "(a -> bool), [a] -> ([a], [a])", documentation = "partition(is_even, [0,1,1,3,7,2,3,4]) == ([0,2,4],[1,1,3,7,3])", declaration = "template <typename UnaryPredicate, typename Container>\nstd::pair<Container, Container> partition\n        (UnaryPredicate pred, const Container& xs)" }
    , { name = "split_at_idxs", signature = "[int], [a] -> [[a]]", documentation = "split_at_idxs([2,5], [0,1,2,3,4,5,6,7]) == [[0,1],[2,3,4],[5,6,7]]", declaration = "template <typename ContainerIdxs, typename ContainerIn,\n        typename ContainerOut = std::vector<ContainerIn>>\nContainerOut split_at_idxs(const ContainerIdxs& idxsIn, const ContainerIn& xs)" }
    , { name = "split_every", signature = "int, [a] -> [[a]]", documentation = "split_every(3, [0,1,2,3,4,5,6,7]) == [[0,1,2],[3,4,5],[6,7]]\nAlso known as chunk.", declaration = "template <typename ContainerIn,\n        typename ContainerOut = std::vector<ContainerIn>>\nContainerOut split_every(std::size_t n, const ContainerIn& xs)" }
    , { name = "split_by_token", signature = "[a], bool, [a] -> [[a]]", documentation = "split_by_token(\", \", \"foo, bar, baz\") == [\"foo\", \"bar\", \"baz\"]", declaration = "template <typename ContainerIn,\n        typename ContainerOut = typename std::vector<ContainerIn>>\nContainerOut split_by_token(const ContainerIn& token,\n        bool allowEmpty, const ContainerIn& xs)" }
    , { name = "count_occurrences", signature = "[a] -> map a int", documentation = "count_occurrences([1,2,2,3,2)) == [(1, 1), (2, 3), (3, 1)]", declaration = "template <typename ContainerIn,\n        typename MapOut = typename std::map<typename ContainerIn::value_type, std::size_t>>\nMapOut count_occurrences(const ContainerIn& xs)" }
    , { name = "run_length_encode_by", signature = "(a, a -> bool), [a] -> [(int, a)]", documentation = "run_length_encode_by((==),[1,2,2,2,2,3,3,2)) == [(1,1),(4,2),(2,3),(1,2)]", declaration = "template <typename BinaryPredicate,\n        typename ContainerIn,\n        typename T = typename ContainerIn::value_type,\n        typename ContainerOut = typename std::vector<std::pair<std::size_t, T>>>\nContainerOut run_length_encode_by(BinaryPredicate pred, const ContainerIn& xs)" }
    , { name = "run_length_encode", signature = "[a] -> [(int, a)]", documentation = "run_length_encode([1,2,2,2,2,3,3,2)) == [(1,1),(4,2),(2,3),(1,2)]", declaration = "template <typename ContainerIn,\n        typename T = typename ContainerIn::value_type,\n        typename ContainerOut = typename std::vector<std::pair<std::size_t, T>>>\nContainerOut run_length_encode(const ContainerIn& xs)" }
    , { name = "run_length_decode", signature = "[(int, a)] -> [a]", documentation = "run_length_decode([(1,1),(4,2),(2,3),(1,2)]) == [1,2,2,2,2,3,3,2)", declaration = "template <typename ContainerIn,\n        typename Pair = typename ContainerIn::value_type,\n        typename Cnt = typename Pair::first_type,\n        typename T = typename Pair::second_type,\n        typename ContainerOut = typename std::vector<T>>\nContainerOut run_length_decode(const ContainerIn& pairs)" }
    , { name = "take_while", signature = "(a -> bool), [a] -> [a]", documentation = "take_while(is_even, [0,2,4,5,6,7,8]) == [0,2,4]", declaration = "template <typename Container, typename UnaryPredicate>\nContainer take_while(UnaryPredicate pred, const Container& xs)" }
    , { name = "drop_while", signature = "(a -> bool), [a] -> [a]", documentation = "drop_while(is_even, [0,2,4,5,6,7,8]) == [5,6,7,8]", declaration = "template <typename Container, typename UnaryPredicate>\nContainer drop_while(UnaryPredicate pred, const Container& xs)" }
    , { name = "span", signature = "(a -> bool), [a] -> ([a], [a])", documentation = "span, applied to a predicate p and a list xs,\nreturns a tuple where first element is longest prefix (possibly empty)\nof xs of elements that satisfy p\nand second element is the remainder of the list.\nspan(is_even, [0,2,4,5,6,7,8]) == ([0,2,4], [5,6,7,8])", declaration = "template <typename Container, typename UnaryPredicate>\nstd::pair<Container, Container> span(UnaryPredicate pred, const Container& xs)" }
    , { name = "is_letter_or_digit", signature = "char -> bool", documentation = "Is character alphanumerical?", declaration = "template <typename String>\nbool is_letter_or_digit(const typename String::value_type& c)" }
    , { name = "is_whitespace", signature = "char -> bool", documentation = "Is character a whitespace.", declaration = "template <typename String>\nbool is_whitespace(const typename String::value_type& c)" }
    , { name = "is_line_break", signature = "char -> bool", documentation = "Newline character ('\\n')?", declaration = "template <typename String>\nbool is_line_break(const typename String::value_type& c)" }
    , { name = "clean_newlines", signature = "string -> string", documentation = "Replaces windows and mac newlines with linux newlines.", declaration = "template <typename String>\nString clean_newlines(const String& str)" }
    , { name = "split_words", signature = "string, bool -> [string]", documentation = "Splits a string by non-letter and non-digit characters.\nsplit_words(\"How are you?\", false) == [\"How\", \"are\", \"you\"]", declaration = "template <typename String, typename ContainerOut = std::vector<String>>\nContainerOut split_words(const String& str, const bool allowEmpty)" }
    , { name = "split_words_by", signature = "string, char, bool -> [string]", documentation = "Splits a string by non-letter and non-digit characters.\nsplit_words(\"How-are you?\", ' ', false) == [\"How-are\", \"you?\"]", declaration = "template <typename String, typename ContainerOut = std::vector<String>>\nContainerOut split_words_by\n        (const String& str, const typename String::value_type delim,\n         const bool allowEmpty)" }
    , { name = "split_words_by_many", signature = "string, [char], bool -> [string]", documentation = "Splits a string by the given delimiter(s).\nsplit_words_by_many(\"How are you?\", \"- o\", false) == [\"H\",\"w\",\"are\",\"y\",\"u?\"]", declaration = "template <typename String, typename ContainerOut = std::vector<String>>\nContainerOut split_words_by_many\n        (const String& str, const String& delims, const bool allowEmpty)" }
    , { name = "split_lines", signature = "string, bool -> [string]", documentation = "Splits a string by the found newlines.\nsplit_lines(\"Hi,\\nhow are you?\", false) == [\"Hi,\", \"How are you\"]", declaration = "template <typename String, typename ContainerOut = std::vector<String>>\nContainerOut split_lines(const String& str, bool allowEmpty)" }
    , { name = "trim_whitespace_left", signature = "string -> string", documentation = "trim_whitespace_left(\"    text  \") == \"text  \"", declaration = "template <typename String>\nString trim_whitespace_left(const String& str)" }
    , { name = "trim_whitespace_right", signature = "string -> string", documentation = "trim_whitespace_right(\"    text  \") == \"    text\"", declaration = "template <typename String>\nString trim_whitespace_right(const String& str)" }
    , { name = "trim_whitespace", signature = "string -> string", documentation = "trim_whitespace(\"    text  \") == \"text\"", declaration = "template <typename String>\nString trim_whitespace(const String& str)" }
    , { name = "to_string_fill_left", signature = "char, int, a -> string", documentation = "to_string_fill_left('0', 5, 42) == \"00042\"", declaration = "template <typename T>\nstd::string to_string_fill_left( const std::string::value_type& filler,\n        std::size_t min_size, const T& x)" }
    , { name = "to_string_fill_right", signature = "char, int, a -> string", documentation = "to_string_fill_right(' ', 5, 42) == \"42   \"", declaration = "template <typename T>\nstd::string to_string_fill_right( const std::string::value_type& filler,\n        std::size_t min_size, const T& x)" }
    , { name = "transform_convert", signature = "(a -> b), [a] -> [b]", documentation = "transform_convert((*2), [1, 3, 4]) == [2, 6, 8]", declaration = "template <typename ContainerOut, typename F, typename ContainerIn>\nContainerOut transform_convert(F f, const ContainerIn& xs)" }
    , { name = "transform_convert", signature = "(int -> a -> b), [a] -> [b]", documentation = "transform_with_idx(f, [6, 4, 7]) == [f(0, 6), f(1, 4), f(2, 7)]", declaration = "template <typename F, typename ContainerIn,\n    typename ContainerOut = typename same_cont_new_t_from_binary_f< ContainerIn, F, std::size_t, typename ContainerIn::value_type>::type>\nContainerOut transform_with_idx(F f, const ContainerIn& xs)" }
    , { name = "transform_and_keep_justs", signature = "(a -> maybe b), [a] -> [b]", documentation = "Map function over values and drop resulting nothings.", declaration = "template <typename F, typename ContainerIn,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename ContainerOut = typename same_cont_new_t<ContainerIn, typename FOut::type>::type>\nContainerOut transform_and_keep_justs(F f, const ContainerIn& xs)" }
    , { name = "transform_and_keep_oks", signature = "(a -> Result b) -> [a] -> [b]", documentation = "Map function over values and drop resulting errors.", declaration = "template <typename F, typename ContainerIn,\n    typename FOut = typename utils::function_traits<F>::result_type,\n    typename ContainerOut = typename same_cont_new_t<ContainerIn, typename FOut::ok_t>::type>\nContainerOut transform_and_keep_oks(F f, const ContainerIn& xs)" }
    , { name = "transform_and_concat", signature = "(a -> [b]), [a] -> [b]", documentation = "Map function over values and concat results.", declaration = "template <typename F, typename ContainerIn,\n    typename ContainerOut = typename same_cont_new_t_from_unary_f<ContainerIn, F>::type::value_type>\nContainerOut transform_and_concat(F f, const ContainerIn& xs)" }
    , { name = "transpose", signature = "[[a]] -> [[a]]", documentation = "[[1, 2, 3], [4, 5, 6]] -> [[1, 4], [2, 5], [3, 6]]", declaration = "template <typename Container>\nContainer transpose(const Container& grid2d)" }
    , { name = "sample", signature = "int, [a] -> [a]", documentation = "Returns n random elements from xs.\nn has to be smaller than or equal to the number of elements in xs.", declaration = "template <typename Container>\nContainer sample(std::size_t n, const Container& xs)" }
    ]