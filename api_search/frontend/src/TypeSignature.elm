module TypeSignature exposing (Signature, parseSignature, showSignature, normalizeSignature, functionCompatibility)

{-| This module provides the possibility to parse Haskell and Elm type signatures.
-}

import Combine as C
import Combine.Char as CC
import Combine.Infix exposing (..)
import Combine.Num as CN
import Char
import Dict
import List exposing ((::))
import List.Extra exposing (permutations, subsequences)
import Maybe
import Result
import String


type Signature
    = Arrow Signature Signature
    | ListType Signature
      -- A Tuple with an empty List is the unit type.
    | Tuple (List Signature)
    | TypeConstructor String
    | TypeApplication Signature Signature
    | VariableType String


type alias ParseResult =
    ( Result (List String) Signature, C.Context )


showSignature : Bool -> Signature -> String
showSignature charListAsString =
    showSignatureHelper charListAsString False False


mapS : (s -> String -> ( s, String )) -> s -> List Signature -> ( List Signature, s )
mapS f s =
    let
        go sig ( sigs, s ) =
            let
                ( sig', s' ) =
                    mapLRS f s sig
            in
                ( sig' :: sigs, s' )
    in
        List.foldl go ( [], s ) >> \( xs, s ) -> ( List.reverse xs, s )



{- http://stackoverflow.com/a/37455356/1866775 -}


mapLRS : (s -> String -> ( s, String )) -> s -> Signature -> ( Signature, s )
mapLRS f s sig =
    case sig of
        Arrow a b ->
            let
                ( a', s' ) =
                    mapLRS f s a

                ( b', s'' ) =
                    mapLRS f s' b
            in
                ( Arrow a' b', s'' )

        TypeConstructor x ->
            ( TypeConstructor x, s )

        VariableType x ->
            let
                ( s', x' ) =
                    f s x
            in
                ( VariableType x', s' )

        TypeApplication a b ->
            let
                ( a', s' ) =
                    mapLRS f s a

                ( b', s'' ) =
                    mapLRS f s' b
            in
                ( TypeApplication a' b', s'' )

        ListType x ->
            let
                ( x', s' ) =
                    mapLRS f s x
            in
                ( ListType x', s' )

        Tuple xs ->
            let
                ( xs', s' ) =
                    mapS f s xs
            in
                ( Tuple xs', s' )


nthVarName : Int -> String
nthVarName i =
    let
        charPart =
            97 + (i `rem` 26) |> Char.fromCode |> String.fromChar

        addNumber =
            i // 26

        numStr =
            if addNumber == 0 then
                ""
            else
                toString addNumber
    in
        charPart ++ numStr



{- Asserts varNames being generated by the same functions. -}


nextFreeVarName : List String -> String
nextFreeVarName varNames =
    nthVarName (List.length varNames)


normalizeSignatureGo :
    Dict.Dict String String
    -> String
    -> ( Dict.Dict String String, String )
normalizeSignatureGo dict str =
    let
        nextFree =
            nextFreeVarName (Dict.keys dict)

        str' =
            Dict.get str dict |> Maybe.withDefault nextFree
    in
        ( Dict.insert str str' dict, str' )


normalizeSignature : Signature -> Signature
normalizeSignature =
    mapLRS normalizeSignatureGo Dict.empty >> fst



--mapLRS (\s -> ( s + 1, s |> Char.fromCode |> String.fromChar )) 97 >> fst


addParenthesis : String -> String
addParenthesis x =
    "(" ++ x ++ ")"


showSignatureHelper : Bool -> Bool -> Bool -> Signature -> String
showSignatureHelper charListAsString arrowsInParens typeAppInParens sig =
    let
        optArrowParens =
            if arrowsInParens then
                addParenthesis
            else
                identity

        optTypeApplicationParens =
            if typeAppInParens then
                addParenthesis
            else
                identity
    in
        case sig of
            Arrow a b ->
                showSignatureHelper charListAsString True False a
                    ++ " -> "
                    ++ showSignatureHelper charListAsString False False b
                    |> optArrowParens

            TypeConstructor x ->
                x

            VariableType x ->
                x

            TypeApplication a b ->
                showSignatureHelper charListAsString False False a
                    ++ " "
                    ++ showSignatureHelper charListAsString True True b
                    |> optTypeApplicationParens

            ListType (TypeConstructor "Char") ->
                if charListAsString then
                    "String"
                else
                    "[Char]"

            ListType x ->
                "[" ++ showSignatureHelper charListAsString False False x ++ "]"

            Tuple xs ->
                String.join ", "
                    (List.map (showSignatureHelper charListAsString False False) xs)
                    |> addParenthesis


listParser : C.Parser Signature
listParser =
    C.brackets (C.rec <| \() -> signatureParser)
        |> C.map ListType


trimSpaces : C.Parser a -> C.Parser a
trimSpaces =
    let
        skipSpaces =
            C.skipMany <| C.choice [ CC.space, CC.tab ]
    in
        C.between skipSpaces skipSpaces


tupleParser : C.Parser Signature
tupleParser =
    let
        innerParser =
            C.sepBy (trimSpaces <| CC.char ',')
                (C.rec <| \() -> signatureParser)
                |> C.map simplify

        simplify xs =
            case xs of
                [ x ] ->
                    x

                _ ->
                    Tuple xs
    in
        trimSpaces innerParser
            |> C.parens


arrowParser : C.Parser Signature
arrowParser =
    let
        arrowOp =
            Arrow <$ trimSpaces (C.string "->")
    in
        C.chainr (C.rec <| \() -> nonAppSignatureParser) arrowOp


isValidTypeApplication : Signature -> Bool
isValidTypeApplication sig =
    case sig of
        TypeConstructor _ ->
            True

        TypeApplication a b ->
            isValidTypeApplication a

        _ ->
            False


typeApplicationParser : C.Parser Signature
typeApplicationParser =
    let
        typeApplyOp =
            TypeApplication <$ C.many1 CC.space

        validate ta =
            if isValidTypeApplication ta then
                C.succeed ta
            else
                C.fail [ "invalid type application" ]
    in
        C.andThen (C.chainl (C.rec <| \() -> nonOpSignatureParser) typeApplyOp)
            validate


typeStartsWithParser : C.Parser Char -> (String -> Signature) -> C.Parser Signature
typeStartsWithParser p tagger =
    [ p |> C.map (\x -> [ x ])
    , C.many <| C.choice [ CC.lower, CC.upper, CC.char '.', CC.char '_', CC.digit ]
    ]
        |> C.sequence
        |> C.map List.concat
        |> C.map (String.fromList >> tagger)


variableTypeParser : C.Parser Signature
variableTypeParser =
    typeStartsWithParser CC.lower VariableType


stringToListChar : Signature -> Signature
stringToListChar sig =
    case sig of
        TypeConstructor "String" ->
            ListType (TypeConstructor "Char")

        _ ->
            sig


fixedTypeParser : C.Parser Signature
fixedTypeParser =
    typeStartsWithParser CC.upper TypeConstructor |> C.map stringToListChar


nonOpSignatureParser : C.Parser Signature
nonOpSignatureParser =
    C.choice
        [ C.rec <| \() -> listParser
        , C.rec <| \() -> tupleParser
        , variableTypeParser
        , fixedTypeParser
        ]


nonAppSignatureParser : C.Parser Signature
nonAppSignatureParser =
    C.choice
        [ C.rec <| \() -> typeApplicationParser
        , C.rec <| \() -> nonOpSignatureParser
        ]


signatureParser : C.Parser Signature
signatureParser =
    C.choice
        [ C.rec <| \() -> arrowParser
        , nonAppSignatureParser
        ]
        |> trimSpaces


parseResultToMaybeSig : ParseResult -> Maybe Signature
parseResultToMaybeSig parseResult =
    case parseResult of
        ( Ok s, { input } ) ->
            if String.isEmpty input then
                Maybe.Just s
            else
                Maybe.Nothing

        _ ->
            Maybe.Nothing


parseSignature : String -> Maybe Signature
parseSignature =
    C.parse signatureParser >> parseResultToMaybeSig


equalityToFloat : a -> a -> Float
equalityToFloat x y =
    if x == y then
        1
    else
        0


functionCompatibility : Signature -> Signature -> Float
functionCompatibility db query =
    case ( db, query ) of
        ( VariableType _, TypeConstructor _ ) ->
            0.95

        ( VariableType _, ListType _ ) ->
            0.8

        ( TypeApplication (TypeConstructor "Maybe") (VariableType x), VariableType y ) ->
            0.8 * equalityToFloat x y

        ( TypeApplication (TypeConstructor "Maybe") (TypeConstructor x), TypeConstructor y ) ->
            0.8 * equalityToFloat x y

        ( Arrow a b, Arrow x y ) ->
            functionCompatibility a x * functionCompatibility b y

        ( TypeConstructor x, TypeConstructor y ) ->
            equalityToFloat x y

        ( VariableType x, VariableType y ) ->
            equalityToFloat x y

        ( TypeApplication a b, TypeApplication x y ) ->
            functionCompatibility a x * functionCompatibility b y

        ( ListType a, ListType x ) ->
            functionCompatibility a x

        ( Tuple xs, Tuple ys ) ->
            if List.length xs > List.length ys then
                List.map
                    (\xs' ->
                        List.map2 functionCompatibility xs' ys
                            |> List.product
                            |> (\x ->
                                    x
                                        * toFloat (List.length ys)
                                        / toFloat (List.length xs)
                               )
                    )
                    (subsequences xs)
                    |> List.maximum
                    |> Maybe.withDefault 0
            else
                List.map
                    (\ys' ->
                        List.map2 functionCompatibility xs ys'
                            |> List.product
                    )
                    (permutations ys)
                    |> List.maximum
                    |> Maybe.withDefault 0

        ( Tuple xs, y ) ->
            List.map
                (\x ->
                    functionCompatibility x y
                        / toFloat (List.length xs)
                )
                xs
                |> List.maximum
                |> Maybe.withDefault 0

        _ ->
            0
